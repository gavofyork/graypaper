\section{Serialization Codec}\label{sec:serialization}

\subsection{Common Terms}

Our codec function $\mathcal{E}$ is used to serialize some term into a sequence of octets. We define the deserialization function $\de$ as the inverse of $\mathcal{E}$ and able to decode some sequence into the original value. The codec is designed such that exactly one value is encoded into any given sequence of octets, and in cases where this is not desirable then we use special codec functions.

\subsubsection{Trivial Encodings}
We define the serialization of $\none$ as the empty sequence:
\begin{equation}
  \encode{\none} \equiv []
\end{equation}

We also define the serialization of an octet-sequence as itself:
\begin{equation}
  \encode{x \in \blob} \equiv x
\end{equation}

We define anonymous tuples to be encoded as the concatenation of their encoded elements:
\begin{equation}
  \encode{\tup{a, b, \dots}} \equiv \encode{a} \concat \encode{b} \concat \dots
\end{equation}

Passing multiple arguments to the serialization functions is equivalent to passing a tuple of those arguments. Formally:
\begin{align}
  \encode{a, b, \dots} &\equiv \encode{\tup{a, b, \dots}}
\end{align}

%We also define the variable-size prefix 29-bit natural serialization function $\se_{4*}$:
%\begin{equation}
%  \se_{4*}\colon\abracegroup{
%    \Nbits{29} &\to \bloboflen{1:4} \\
%    x &\mapsto \begin{cases}
%      [0] &\when x = 0 \\
%      \left[2^8-2^{8-l} + \ffrac{x}{2^{8l}}\right] \concat \fixedencode{l}{x \bmod 2^{8l}} &\when \exists l \in \N_3 : 2^{7l} \le x < 2^{7(l+1)} \\
%      \left[2^8-2^5 + \ffrac{x}{2^{24}}\right] \concat \fixedencode{3}{x \bmod 2^{24}} &\when 2^{21} \le x < 2^{29} \\
%    \end{cases}
%  }
%\end{equation}

We define general natural number serialization, able to encode naturals of up to $2^{64}$, as:
\begin{equation}
  \se\colon\abracegroup{
    \Nbits{64} &\to \bloboflen{1:9} \\
    x &\mapsto \begin{cases}
      [0] &\when x = 0 \\
      \left[2^8-2^{8-l} + \ffrac{x}{2^{8l}}\right] \concat \fixedencode{l}{x \bmod 2^{8l}} &\when \exists l \in \N_8 : 2^{7l} \le x < 2^{7(l+1)} \\
      [2^8-1] \concat \fixedencode{8}{x} &\otherwhen x < 2^{64} \\
    \end{cases}
  }
\end{equation}

\subsubsection{Sequence Encoding}
We define the sequence serialization function $\encode{\sequence{T}}$ for any $T$ which is itself a subset of the domain of $\se$. We simply concatenate the serializations of each element in the sequence in turn:
\begin{equation}
  \encode{[\mathbf{i}_0, \mathbf{i}_1, ...]} \equiv \encode{\mathbf{i}_0} \concat \encode{\mathbf{i}_1} \concat \dots
\end{equation}

Thus, conveniently, fixed length octet sequences (\eg hashes $\hash$ and its variants) have an identity serialization.

\subsubsection{Discriminator Encoding}
When we have sets of heterogeneous items such as a union of different kinds of tuples or sequences of different length, we require a discriminator to determine the nature of the encoded item for successful deserialization. Discriminators are encoded as a natural and are encoded immediately prior to the item.

We generally use a \emph{length discriminator} when serializing sequence terms which have variable length (\eg general blobs $\blob$ or unbound numeric sequences $\sequence{\N}$) (though this is omitted in the case of fixed-length terms such as hashes $\hash$).\footnote{Note that since specific values may belong to both sets which would need a discriminator and those that would not then we are sadly unable to introduce a function capable of serializing corresponding to the \emph{term}'s limitation. A more sophisticated formalism than basic set-theory would be needed, capable of taking into account not simply the value but the term from which or to which it belongs in order to do this succinctly.} In this case, we simply prefix the term its length prior to encoding. Thus, for some term $y \in \tup{x \in \blob, \dots}$, we would generally define its serialized form to be $\encode{\len{x}}\concat\encode{x}\concat\dots$. To avoid repetition of the term in such cases, we define the notation $\var{x}$ to mean that the term of value $x$ is variable in size and requires a length discriminator. Formally:
\begin{equation}
  \var{x} \equiv \tup{\len{x}, x}\text{ thus }\encode{\var{x}} \equiv \encode{\len{x}}\concat\encode{x}
\end{equation}

We also define a convenient discriminator operator $\maybe{x}$ specifically for terms defined by some serializable set in union with $\none$ (generally denoted for some set $S$ as $\optional{S}$):
\begin{align}
  \maybe{x} \equiv \begin{cases}
    0 &\when x = \none \\
    (1, x) &\otherwise
  \end{cases}
\end{align}

\subsubsection{Bit Sequence Encoding}
A sequence of bits $b \in \bitstring$ is a special case since encoding each individual bit as an octet would be very wasteful. We instead pack the bits into octets in order of least significant to most, and arrange into an octet stream. In the case of a variable length sequence, then the length is prefixed as in the general case.
\begin{align}
  \encode{b \in \bitstring} &\equiv \begin{cases}
    \sq{} &\when b = \sq{} \\
    \sq{
      \sum\limits_{i=0}^{\min(8, \len{b})}
      b\sub{i} \cdot 2^i
    } \concat \encode{b\interval{8}{}} &\otherwise\\
  \end{cases}
\end{align}

\subsubsection{Dictionary Encoding}
In general, dictionaries are placed in the Merkle trie directly (see appendix \ref{sec:merklization} for details). However, small dictionaries may reasonably be encoded as a sequence of pairs ordered by the key. Formally:
\begin{equation}
  \forall K, V: \encode{d \in \dict{K}{V}} \equiv
    \encode{
      \var{\sq{
        \orderby{k}{
          \build{
            \tup{\encode{k}, \encode{d[k]}}
          }{
            k \in \keys{d}
          }
        }
      }}
    }
\end{equation}

%The second is as a sequence of encoded values only, with each entry having an implicit key according to an enumeration over its domain. This is typically used when the domain is small in magnitude and typically similar in magnitude to the active domain. In order to account for the possibility of a key not existing in the dictionary (\ie the domain and the active domain not being equal) we prefix each value with an octet of one to indicate that the key is indeed present in the dictionary and place an octet of zero if the implied key is not.
%
%We provide a function $\signdata$ to deliver this from a regular dictionary:
%\begin{equation}
%  \forall K, V: \signdata(d \in \dict{K}{V}) \equiv \var{\sqorderby{k}{\begin{aligned}
%    &[1] \concat \encode{d[k]} &&\ \when k \in \keys{d} \\
%    &[0] &&\ \otherwise
%  \end{aligned}
%  \,\middle\mid\, k \in K}}
%\end{equation}

%Finally, we may also encode a dictionary only insofar as we encode the keys and encode the values; in this case the result is not a sequence of octets but rather a mapping of octet-sequences to octet-sequences. This is useful in defining the process of Merklization. We define the function $\se_D$ to deliver this from a regular dictionary:
%\begin{equation}
%  \forall K, V: \se_D(d \in \dict{K}{V}) \equiv r \suchthat k \in \keys{d} \Leftrightarrow \encode{k} \in \keys{r} \wedge \forall k \in \keys{d} : r[\encode{k}] = \encode{d[k]}
%\end{equation}

\subsubsection{Set Encoding}
For any values which are sets and don't already have a defined encoding above, we define the serialization of a set as the serialization of the set's elements in proper order. Formally:
\begin{equation}
  \encode{\set{a, b, c, \dots}} \equiv \encode{a} \concat \encode{b} \concat \encode{c} \concat \dots \where a < b < c < \dots
\end{equation}

\subsubsection{Fixed-length Integer Encoding}
We first define the trivial natural number serialization functions which are subscripted by the number of octets of the final sequence. Values are encoded in a regular little-endian fashion. This is utilized for almost all integer encoding across the protocol. Formally:
\begin{equation}
  \se_{l \in \N}\colon\abracegroup{
    \Nbits{8l} &\to \bloboflen{l} \\
    x &\mapsto \begin{cases}
      sq{} &\when l = 0 \\
      sq{x \bmod 256} \concat \se_{l - 1}\left(\floor{\frac{x}{256}}\right) &\otherwise
    \end{cases}
  }
\end{equation}

For non-natural arguments, $\se_{l \in \N}$ corresponds to the definitions of $\se$, except that recursive elements are made as $\sefixed{l}$ rather than $\se$. Thus:
\begin{align}
  \fixedencode{l \in \N}{a, b, \dots} &\equiv \fixedencode{l}{\tup{a, b, \dots}}\\
  \fixedencode{l \in \N}{\tup{a, b, \dots}} &\equiv \fixedencode{l}{a} \concat \fixedencode{l}{b} \concat \dots\\
  \fixedencode{l \in \N}{\sq{\mathbf{i}_0, \mathbf{i}_1, \dots}} &\equiv \fixedencode{l}{\mathbf{i}_0} \concat \fixedencode{l}{\mathbf{i}_1} \concat \dots
\end{align}

And so on.

\subsection{Block Serialization}

A block $\block$ is serialized as a tuple of its elements in regular order, as implied in equations \ref{eq:block}, \ref{eq:extrinsic} and \ref{eq:header}. For the header, we define both the regular serialization and the unsigned serialization $\se_U$. Formally:

\newcommand*{\seresult}{O}
\begin{align}
  \encode{\block} &= \se\,\left\lparen
    \header,\ \se_T(\xttickets),\ \se_P(\xtpreimages),\ \se_G(\xtguarantees),\ \se_A(\xtassurances),\ \se_D(\xtdisputes)
  \right\rparen \\
  \se_T(\xttickets) &= \encode{\var{\xttickets}} \\
  \se_P(\xtpreimages) &= \encode{\var{\sq{\build{\tup{s, \var{p}}}{\tup{s, p} \orderedin \xtpreimages}}}} \\
  \se_G(\xtguarantees) &= \encode{\var{\sq{\build{\tup{w, \fixedencode{4}{t}, \var{a}}}{\tup{w, t, a} \orderedin \xtguarantees}}}} \\
  \se_A(\xtassurances) &= \encode{\var{\sq{\build{\tup{a, f, \fixedencode{2}{v}, s}}{\tup{a, f, v, s} \orderedin \xtassurances}}}} \\
  \se_D((\mathbf{v}, \mathbf{c}, \mathbf{f})) &= \se(\var{[(r, \fixedencode{4}{a}, \sq{\build{(v, \fixedencode{2}{i}, s)}{(v, i, s) \orderedin \mathbf{j}}}) \mid (r, a, \mathbf{j}) \orderedin \mathbf{v}]}, \var{\mathbf{c}}, \var{\mathbf{f}}) \\
  \encode{\mathbf{H}} &= \se_U(\mathbf{H})\concat\encode{\H_\¬sealsig} \\
  \se_U(\mathbf{H}) &= \encode{\H_\¬parent,\H_\¬priorstateroot,\H_\¬extrinsichash}\concat\fixedencode{4}{\H_\¬timeslot}\concat\encode{\maybe{\H_\¬epochmark},\maybe{\H_\¬winnersmark},\fixedencode{2}{\H_\¬authorindex},\H_\¬vrfsig,\var{\H_\¬offendersmark}}\\
  \encode{x \in \workcontext} &\equiv \encode{x_a, x_s, x_b, x_l}\concat\fixedencode{4}{x_t}\concat\encode{\var{x_\mathbf{p}}}\\
  \encode{x \in \avspec} &\equiv \encode{x_h} \concat \fixedencode{4}{x_l}\concat\encode{x_u, x_e} \concat \fixedencode{2}{x_n} \\
  \encode{x \in \mathbb{L}} &\equiv \se(\fixedencode{4}{x_s}, x_c, x_y, \fixedencode{8}{x_g}, x_u, x_i, x_x, x_z, x_e, \seresult(x_\wd¬result))\\
  \encode{x \in \workreport} &\equiv \encode{x_s, x_x, x_c, x_a, x_g, \var{x_\wr¬authtrace}, \var{x_\mathbf{l}}, \var{x_\wr¬digests}} \\
  \encode{x \in \workpackage} &\equiv \encode{\fixedencode{4}{x_\wp¬authcodehost}, x_\wp¬authcodehash, x_\wp¬context, \var{x_\wp¬authtoken}, \var{x_\wp¬authconfig}, \var{x_\wp¬workitems}} \\
  % TODO: \fixedencode{4}{i} should be just \encode{i}, but we should wait for this to be written.
  \encode{x \in \workitem} &\equiv \se(
    \fixedencode{4}{x_\wi¬service},
    x_\wi¬codehash,
    \fixedencode{8}{x_\wi¬refgaslimit},
    \fixedencode{8}{x_\wi¬accgaslimit},
    \fixedencode{2}{x_\wi¬exportcount}
    \var{x_\wi¬payload},
    \var{\se_I^\#(x_\wi¬importsegments)},
    \var{\sq{\tup{h, \fixedencode{4}{i}} \mid \tup{h, i} \orderedin x_\wi¬extrinsics}},
  ) \\
  \encode{x \in \safroleticket} &\equiv \encode{x_\mathbf{y}, x_r} \\
  \encode{x \in \defxfer} &\equiv \se(\fixedencode{4}{x_s}, \fixedencode{4}{x_d}, \fixedencode{8}{x_a}, \encode{x_m}, \fixedencode{8}{x_g}) \\
  \encode{x \in \operandtuple} &\equiv \se(x_\ot¬packagehash, x_\ot¬segroot, x_\ot¬authorizer,  x_\ot¬payloadhash, x_\ot¬gaslimit, \seresult(x_\ot¬result), \var{x_\ot¬authtrace}) \\
  \seresult(o \in \workerror \cup \blob) &\equiv \begin{cases}
    (0, \var{o}) &\when o \in \blob \\
    1 &\when o = \infty \\
    2 &\when o = \panic \\
    3 &\when o = \badexports \\
    4 &\when o = \oversize \\
    5 &\when o = \token{BAD} \\
    6 &\when o = \token{BIG} \\
  \end{cases}\\
  \se_I(h \in \hash \cup \hash^\boxplus, i \in \Nbits{15}) &\equiv \begin{cases}
    (h, \fixedencode{2}{i}) &\when h \in \hash\\
    (r, \fixedencode{2}{i + 2^{15}}) &\when \exists r \in \hash, h = r^\boxplus\\
  \end{cases}
\end{align}

Note the use of $O$ above to succinctly encode the result of a work item and the slight transformations of $\xtguarantees$ and $\xtpreimages$ to take account of the fact their inner tuples contain variable-length sequence terms $a$ and $p$ which need length discriminators.
