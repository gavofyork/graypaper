\section{Polka Virtual Machine}\label{sec:virtualmachine}

%TODO: First 64KB of memory is always inaccessible.

\subsection{Basic Definition}
\newcommand*{\instr}[1]{\text{{\small \texttt{#1}}}}
\newcommand*{\regs}{\seq{\N_R}_{13}}
\newcommand*{\reg}{{\omega}}
\newcommand*{\mem}{{\mu}}
\newcommand*{\memr}{\mem^{\circlearrowleft}}
\newcommand*{\memwr}{{\mem'}^{\circlearrowleft}}
\newcommand*{\ram}{\mathbb{M}}
\newcommand*{\rnp}[1]{P(#1)}
\newcommand*{\rnq}[1]{Q(#1)}
\newcommand*{\continue}{\blacktriangleright}
\newcommand*{\gas}{\xi_\Delta}
\newcommand*{\instrlen}{\ell}
\newcommand*{\bitsfunc}[1]{\mathcal{B}_{#1}}
\newcommand*{\unbitsfunc}[1]{\bitsfunc{#1}^{-1}}
\newcommand*{\bits}[1]{\bitsn{4}{#1}}
\newcommand*{\unbits}[1]{\unbitsn{4}{#1}}
\newcommand*{\bitsn}[2]{\bitsfunc{#1}(#2)}
\newcommand*{\unbitsn}[2]{\unbitsfunc{#1}(#2)}
\newcommand*{\signfunc}[1]{\mathcal{Z}_{#1}}
\newcommand*{\unsignfunc}[1]{\signfunc{#1}^{-1} }
\newcommand*{\signed}[1]{\signedn{4}{#1}}
\newcommand*{\unsigned}[1]{\unsignedn{4}{#1}}
\newcommand*{\signedn}[2]{\signfunc{#1}(#2)}
\newcommand*{\unsignedn}[2]{\unsignfunc{#1}(#2)}
%\newcommand*{\signed}[1]{{{}^{\mathord{\mp}}#1}}
%\newcommand*{\unsigned}[1]{{{}^{\mathord{+}}#1}}
%\newcommand*{\signedn}[2]{{{}_{#1}^{\mathord{\mp}}#2}}
%\newcommand*{\unsignedn}[2]{{{}_{#1}^{\mathord{+}}#2}}
\newcommand*{\RA}{\token{RA}}
\newcommand*{\SP}{\token{SP}}
\newcommand*{\T}{\token{T}}
\renewcommand*{\S}{\token{S}}
\newcommand*{\A}{\token{A}}
\newcommand*{\basicblocks}{\varpi}
\newcommand*{\instructions}{\zeta}
\newcommand*{\immed}{\nu}

We declare the general \textsc{pvm} function $\Psi$. We assume a single-step invocation function define $\Psi_1$ and define the full \textsc{pvm} recursively as a sequence of such mutations up until the single-step mutation results in a halting condition.
\begin{equation}
  \Psi\colon \left\{\begin{aligned}
    (\Y, \N_R, \N_G, \regs, \ram) &\to (\{\halt, \panic, \oog\} \cup \{\fault\} \times \N_R \cup \{\host\} \times \N_R, \N_R, \Z_G, \regs, \ram)\\
    (\mathbf{p}, \imath, \xi, \omega, \mem) &\mapsto \begin{cases}
      \Psi(\mathbf{p}, \imath', \xi', \omega', \mem') &\when \varepsilon = \continue\\
      (\oog, \imath', \xi', \omega', \mem') &\when \xi' < 0\\
      (\varepsilon, \imath', \xi', \omega', \mem') &\otherwise
    \end{cases} \\
    \where (\varepsilon, \imath', \xi', \omega', \mem') &= \Psi_1(\mathbf{c}, \mathbf{k}, \mathbf{j}, \imath, \xi, \omega, \mem)\\
    \also \mathbf{p} &= \se(|\mathbf{j}|) \frown \se_1(z) \frown \se(|\mathbf{c}|) \frown \se_z(\mathbf{j}) \frown \se(\mathbf{c}) \frown \se(\mathbf{k})\,,\ |\mathbf{k}| = |\mathbf{c}|
    \end{aligned}\right.
\end{equation}

If the latter condition cannot be satisfied, then $(\panic, \imath, \xi, \omega, \mem)$ is the result.

The \textsc{pvm} exit reason $\varepsilon \in \{\halt, \panic, \oog\} \cup \{\fault, \host\} \times \N_R$ may be one of regular halt $\halt$, panic $\panic$ or out-of-gas $\oog$, or alternatively a host-call $\host$, in which the host-call identifier is associated, or page-fault $\fault$ in which case the address into \textsc{ram} is associated.

\subsection{Instructions, Opcodes and Skip-distance}

The program blob $\mathbf{p}$ is split into a series of octets which make up the \emph{instruction data} $\mathbf{c}$ and the \emph{opcode bitmask} $\mathbf{k}$ as well as the \emph{dynamic jump table}, $\mathbf{j}$. The former two imply an instruction sequence, and by extension a \emph{basic-block sequence}, itself a sequence of indices of the instructions which follow a \emph{block-termination} instruction.

The latter, dynamic jump table, is a sequence of indices into the instruction data blob and is indexed into when dynamically-computed jumps are taken. It is encoded as a sequence of natural numbers (i.e. non-negative integers) each encoded with the same length in octets. This length, term $z$ above, is itself encoded prior.

The \textsc{pvm} counts instructions in octet terms (rather than in terms of instructions) and it is thus convenient to define which octets represent the beginning of an instruction, \ie the opcode octet, and which do not. This is the purpose of $\mathbf{k}$, the instruction-opcode bitmask. We assert that the length of the bitmask is equal to the length of the instruction blob.

\newcommand{\Fskip}{\text{skip}}

We define the Skip function $\Fskip$ which provides the number of octets, minus one, to the next instruction's opcode, given the index of instruction's opcode index into $\mathbf{c}$ (and by extension $\mathbf{k}$):
\begin{equation}
  \Fskip\colon\left\{\begin{aligned}
    \N &\to \N\\
    i &\mapsto \min(24,\ j \in \N : (\mathbf{k} \frown [1, 1, \dots])_{i + 1 + j} = 1)
  \end{aligned}\right.
\end{equation}

The Skip function appends $\mathbf{k}$ with a sequence of set bits in order to ensure a well-defined result for the final instruction $\Fskip(|\mathbf{c}| - 1)$.

Given some instruction-index $i$, its opcode is readily expressed as $\mathbf{c}_i$ and the distance in octets to move forward to the next instruction is $1 + \Fskip(i)$. However, each instruction's ``length'' (defined as the number of contiguous octets starting with the opcode which are needed to fully define the instruction's semantics) is left implicit though limited to being at most 16.

We define $\instructions$ as being equivalent to the instructions $\mathbf{c}$ except with an indefinite sequence of zeroes suffixed to ensure that no out-of-bounds access is possible. This effectively defines any otherwise-undefined arguments to the final instruction and ensures that a trap will occur if the program counter passes beyond the program code. Formally:
\begin{equation}\label{eq:instructions}
  \instructions \equiv \mathbf{c} \concat \sq{0, 0, \dots}
\end{equation}

\subsection{Basic Blocks and Termination Instructions}

Instructions of the following opcodes are considered basic-block termination instructions; other than $\token{trap}$ \& $\token{fallthrough}$, they correspond to instructions which may define the instruction-counter to be something other than its prior value plus the instruction's skip amount:
\begin{itemize}
  \item Trap and fallthrough: $\token{trap}$
  , $\token{fallthrough}$
  \item Jumps: $\token{jump}$
  , $\token{jump\_ind}$
  \item Load-and-Jumps: $\token{load\_imm\_jump}$
  , $\token{load\_imm\_jump\_ind}$
  \item Branches: $\token{branch\_eq}$
  , $\token{branch\_ne}$
  , $\token{branch\_ge\_u}$
  , $\token{branch\_ge\_s}$
  , $\token{branch\_lt\_u}$
  , $\token{branch\_lt\_s}$
  , $\token{branch\_eq\_imm}$
  , $\token{branch\_ne\_imm}$
  \item Immediate branches: $\token{branch\_lt\_u\_imm}$
  , $\token{branch\_lt\_s\_imm}$
  , $\token{branch\_le\_u\_imm}$
  , $\token{branch\_le\_s\_imm}$
  , $\token{branch\_ge\_u\_imm}$
  , $\token{branch\_ge\_s\_imm}$
  , $\token{branch\_gt\_u\_imm}$
  , $\token{branch\_gt\_s\_imm}$
\end{itemize}

We denote this set, as opcode indices rather than names, as $T$. We define the instruction opcode indices denoting the beginning of basic-blocks as $\basicblocks$:
\begin{equation}
  \basicblocks \equiv [0] \concat [n + 1 + \Fskip(n) \mid n \orderedin \N_{|\mathbf{c}|} \wedge \mathbf{k}_n = 1 \wedge \mathbf{c}_n \in T]
\end{equation}

\subsection{Single-Step State Transition}

We must now define the single-step \textsc{pvm} state-transition function $\Psi_1$:
\begin{equation}
  \Psi_1\colon \left\{\begin{aligned}
    (\Y, \mathbb{B}, \seq{\N_R}, \N_R, \N_G, \regs, \ram) &\to (\{\panic, \halt, \continue \} \cup \{\fault, \host\} \times \N_R, \Z_G, \regs, \ram)\\
    (\mathbf{c}, \mathbf{k}, \mathbf{j}, \imath, \xi, \omega, \mem) &\mapsto (\varepsilon, \imath', \xi', \omega', \mem')
  \end{aligned}\right.
\end{equation}

We define $\varepsilon$ together with the posterior values (denoted as prime) of each of the items of the machine state as being in accordance with the table below.

%We alias the registers $\omega$ to their \textsc{risc-v} specification name:
%\begin{equation}
%  (\RA, \SP, \T_0, \T_1, \T_2, \S_0, \S_1, \A_0, \A_1, \A_2, \A_3, \A_4, \A_5) \equiv \omega,\qquad
%  (\RA', \SP', \T_0', \T_1', \T_2', \S_0', \S_1', \A_0', \A_1', \A_2', \A_3', \A_4', \A_5') \equiv \omega'
%\end{equation}

In general, when transitioning machine state for an instruction a number of conditions hold true and instructions are defined essentially by their exceptions to these rules. Specifically, the machine does not halt, the instruction counter increments by one, the gas remaining is reduced by the amount corresponding to the instruction type and \textsc{ram} \& registers are unchanged. Formally:
\begin{equation}
  \varepsilon = \continue,\quad \imath' = \imath + 1 + \Fskip(\imath),\quad \xi' = \xi - \gas,\quad \omega' = \omega,\quad\mem' = \mem \text{ except as indicated }
\end{equation}

Where \textsc{ram} must be inspected and yet access is not possible, then machine state is unchanged, and the exit reason is a fault with the lowest address to be read which is inaccessible. More formally, let $\mathbf{a}$ be the set of indices in to which $\mem$ must be subscripted in order to calculate the result of $\Psi_1$. If $\mathbf{a} \not\subset \mathbb{V}_\mem$ then let $\varepsilon=\fault \times \text{min}(\mathbf{a} \setminus \mathbb{V}_\mem)$.

Similarly, where \textsc{ram} must be mutated and yet mutable access is not possible, then machine state is unchanged, and the exit reason is a fault with the lowest address to be read which is inaccessible. More formally, let $\mathbf{a}$ be the set of indices in to which $\mem'$ must be subscripted in order to calculate the result of $\Psi_1$. If $\mathbf{a} \not\subset \mathbb{V}^*_\mem$ then let $\varepsilon=\fault \times \text{min}(\mathbf{a} \setminus \mathbb{V}^*_\mem)$.

We define signed/unsigned transitions for various octet widths:
\begin{align}
  \label{eq:signedfunc}
  \signfunc{n \in \N}&\colon\left\{\begin{aligned}
    \N_{2^{8n}} &\to \Z_{-2^{8n-1}\dots2^{8n-1}}\\
    a &\mapsto \begin{cases}
      a &\when a < 2^{8n-1} \\
      a -\ 2^{8n} &\otherwise
    \end{cases}
  \end{aligned}\right.\\
  \unsignfunc{n \in \N}&\colon\left\{\begin{aligned}
    \Z_{-2^{8n-1}\dots2^{8n-1}} &\to \N_{2^{8n}}\\
    a &\mapsto (2^{8n} + a) \bmod 2^{8n}
  \end{aligned}\right.\\
  \label{eq:bitsfunc}
  \bitsfunc{n\in\N}&\colon\left\{\begin{aligned}
    \N_{2^{8n}} &\to \mathbb{B}_{8n}\\
    x &\mapsto \mathbf{y}: \forall i \in \N_{2^{8n}} : \mathbf{y}[i] \Leftrightarrow \ffrac{x}{2^i}\bmod 2
  \end{aligned}\right.\\
  \unbitsfunc{n\in\N}&\colon\left\{\begin{aligned}
    \mathbb{B}_{8n} &\to \N_{2^{8n}}\\
    \mathbf{x} &\mapsto y: \sum_{i \in \N_{2^{8n}}} \mathbf{x}_i \cdot 2^i
  \end{aligned}\right.
\end{align}

\newcommand{\sext}{\mathcal{X}}

Immediate arguments are encoded in little-endian format with the most-significant bit being the sign bit. They may be compactly encoded by eliding more significant octets. Elided octets are assumed to be zero if the \textsc{msb} of the value is zero, and 255 otherwise. This allows for compact representation of both positive and negative encoded values. We thus define the signed extension function operating on an input of $n$ octets as $\sext_n$:
\begin{align}\label{eq:signedextension}
  \sext_{n\in\{0, 1, 2, 3, 4\}}\colon\left\{\begin{aligned}
    \N_{2^{8n}} &\to \N_{2^{32}}\\
    x &\mapsto x + \ffrac{x}{2^{8n-1}}(2^{32}-2^{8n})
  \end{aligned}\right.
\end{align}

Any alterations of the program counter stemming from a static jump, call or branch must be to the start of a basic block or else a panic occurs. Hypotheticals are not considered. Formally:
\begin{equation}
  \token{branch}(b, C) \implies (\varepsilon, \imath') = \begin{cases}
    (\continue, \imath) &\when \lnot C \\
    (\panic, \imath) &\otherwhen b \not\in \basicblocks \\
    (\continue, b) &\otherwise
  \end{cases}
\end{equation}

Jumps whose next instruction is dynamically computed must use an address which may be indexed into the jump-table $\mathbf{j}$. Through a quirk of tooling\footnote{The popular code generation backend \textsc{llvm} requires and assumes in its code generation that dynamically computed jump destinations always have a certain memory alignment. Since at present we depend on this for our tooling, we must acquiesce to its assumptions.}, we define the dynamic address required by the instructions as the jump table index incremented by one and then multiplied by our jump alignment factor $\mathsf{Z}_A = 2$.

As with other irregular alterations to the program counter, target code index must be the start of a basic block or else a panic occurs. Formally:
\begin{equation}\label{eq:jumptablealignment}
  \token{djump}(a) \implies (\varepsilon, \imath') = \begin{cases}
    (\halt, \imath) &\when a = 2^{32} - 2^{16}\\
    (\panic, \imath) &\otherwhen a = 0 \vee a > |\mathbf{j}|\cdot\mathsf{Z}_A \vee a \bmod \mathsf{Z}_A \ne 0 \vee \mathbf{j}_{(\nicefrac{a}{\mathsf{Z}_A}) - 1} \not\in \basicblocks \\
    (\continue, \mathbf{j}_{(\nicefrac{a}{\mathsf{Z}_A}) - 1}) &\otherwise
  \end{cases}
\end{equation}

\subsection{Instruction Tables}\label{sec:instructiontables}

Note that in the case that the opcode is not defined in the following tables then the instruction is considered invalid, and it results in a panic; $\varepsilon=\panic$.

We assume the skip length $\ell$ is well-defined:
\begin{equation}
  \ell \equiv \Fskip(\imath)
\end{equation}

\subsubsection{Instructions without Arguments}

\newcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{20mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  0&\token{trap}&0&$\varepsilon = \panic$\\
  \mrule
  17&\token{fallthrough}&0&\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Immediate}
\begin{equation}
\begin{aligned}
  \using l_X = \min(4, \ell) \,,\quad
  \immed_X \equiv \sext_{l_X}(\de_{l_X}(\instructions_{\imath+1\dots+l_X}))
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  78&\token{ecalli}&0&$\varepsilon = \host \times \immed_X$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Two Immediates}
\begin{equation}
\begin{aligned}
    \using l_X &= \min(4, \instructions_{\imath+1} \bmod 8) \,,\quad&
    \immed_X &\equiv \sext_{l_X}(\de_{l_X}(\instructions_{\imath+2\dots+l_X})) \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
    \immed_Y &\equiv \sext_{l_Y}(\de_{l_Y}(\instructions_{\imath+2+l_X\dots+l_Y}))
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  62&\token{store\_imm\_u8}&0&${\mem'}^\circlearrowleft_{\immed_X} = \immed_Y \bmod 2^8 $\\ \mrule
  79&\token{store\_imm\_u16}&0&${\mem'}^\circlearrowleft_{\immed_X\dots+2} = \se_2(\immed_Y \bmod 2^{16})$\\ \mrule
  38&\token{store\_imm\_u32}&0&${\mem'}^\circlearrowleft_{\immed_X\dots+4} = \se_4(\immed_Y)$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Offset}
\begin{equation}
\begin{aligned}
  \using l_X = \min(4, \ell) \,,\quad
  \immed_X \equiv \imath + \signfunc{l_X}(\de_{l_X}(\instructions_{\imath+1\dots+l_X}))
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  5&\token{jump}&0&$\token{branch}(\immed_X, \top)$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register \& One Immediate}
\begin{equation}
\begin{aligned}
    \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
    \immed_X &\equiv \sext_{l_X}(\de_{l_X}(\instructions_{\imath+2\dots+l_X}))
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  19&\token{jump\_ind}&0&$\token{djump}((\reg_A + \immed_X) \bmod 2^{32})$\\ \mrule
  4&\token{load\_imm}&0&$\reg'_A = \immed_X$\\ \mrule
  60&\token{load\_u8}&0&$\reg'_A = \mem_{\immed_X}$\\ \mrule
  74&\token{load\_i8}&0&$\reg'_A = \unsigned{\signedn{1}{\mem_{\immed_X}}}$\\ \mrule
  76&\token{load\_u16}&0&$\reg'_A = \de_2(\memr_{\immed_X\dots+2})$\\ \mrule
  66&\token{load\_i16}&0&$\reg'_A = \unsigned{\signedn{2}{\de_2(\memr_{\immed_X\dots+2})}}$\\ \mrule
  10&\token{load\_u32}&0&$\reg'_A = \de_4(\memr_{\immed_X\dots+4})$\\ \mrule
  71&\token{store\_u8}&0&$\memwr_{\immed_X} = \reg_A \bmod 2^8$\\ \mrule
  69&\token{store\_u16}&0&$\memwr_{\immed_X\dots+2} = \se_2(\reg_A \bmod 2^{16})$\\ \mrule
  22&\token{store\_u32}&0&$\memwr_{\immed_X\dots+4} = \se_4(\reg_A)$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register \& Two Immediates}
\begin{equation}
\begin{aligned}
    \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using l_X &= \min(4, \ffrac{\instructions_{\imath+1}}{16} \bmod 8) \,,\quad&
    \immed_X &= \sext_{l_X}(\de_{l_X}(\instructions_{\imath+2\dots+l_X})) \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
    \immed_Y &= \sext_{l_Y}(\de_{l_Y}(\instructions_{\imath+2+l_X\dots+l_Y}))
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  26&\token{store\_imm\_ind\_u8}&0&$\memwr_{\reg_A + \immed_X} = \immed_Y \bmod 2^8$\\ \mrule
  54&\token{store\_imm\_ind\_u16}&0&$\memwr_{\reg_A + \immed_X \dots+ 2} = \se_2(\immed_Y \bmod 2^{16})$\\ \mrule
  13&\token{store\_imm\_ind\_u32}&0&$\memwr_{\reg_A + \immed_X \dots+ 4} = \se_4(\immed_Y)$\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register, One Immediate and One Offset}
\begin{equation}
  \begin{aligned}
      \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
      \reg_A &\equiv \reg_{r_A} \,,\quad
      \reg'_A \equiv \reg'_{r_A} \\
      \using l_X &= \min(4, \ffrac{\instructions_{\imath+1}}{16} \bmod 8) \,,\quad&
      \immed_X &= \sext_{l_X}(\de_{l_X}(\instructions_{\imath+2\dots+l_X})) \\
      \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
      \immed_Y &= \imath + \signfunc{l_Y}(\de_{l_Y}(\instructions_{\imath+2+l_X\dots+l_Y}))
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  6&\token{load\_imm\_jump}&0&$\token{branch}(\immed_Y, \top)\ ,\qquad \reg_A' = \immed_X$\\ \mrule
  7&\token{branch\_eq\_imm}&0&$\token{branch}(\immed_Y, \reg_A = \immed_X)$\\ \mrule
  15&\token{branch\_ne\_imm}&0&$\token{branch}(\immed_Y, \reg_A \ne \immed_X)$\\ \mrule
  44&\token{branch\_lt\_u\_imm}&0&$\token{branch}(\immed_Y, \reg_A < \immed_X)$\\ \mrule
  59&\token{branch\_le\_u\_imm}&0&$\token{branch}(\immed_Y, \reg_A \le \immed_X)$\\ \mrule
  52&\token{branch\_ge\_u\_imm}&0&$\token{branch}(\immed_Y, \reg_A \ge \immed_X)$\\ \mrule
  50&\token{branch\_gt\_u\_imm}&0&$\token{branch}(\immed_Y, \reg_A > \immed_X)$\\ \mrule
  32&\token{branch\_lt\_s\_imm}&0&$\token{branch}(\immed_Y, \signed{\reg_A} < \signed{\immed_X})$\\ \mrule
  46&\token{branch\_le\_s\_imm}&0&$\token{branch}(\immed_Y, \signed{\reg_A} \le \signed{\immed_X})$\\ \mrule
  45&\token{branch\_ge\_s\_imm}&0&$\token{branch}(\immed_Y, \signed{\reg_A} \ge \signed{\immed_X})$\\ \mrule
  53&\token{branch\_gt\_s\_imm}&0&$\token{branch}(\immed_Y, \signed{\reg_A} > \signed{\immed_X})$\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Two Registers}
\begin{equation}
\begin{aligned}
  \using r_D &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_D &\equiv \reg_{r_D} \,,\quad
  \reg'_D \equiv \reg'_{r_D} \\
  \using r_A &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  82&\token{move\_reg}&0&$\reg'_D = \reg_A$\\ \mrule
  87&\token{sbrk}&0&$\begin{aligned}
    \reg'_D \equiv &\min(x \in \N_R): \\
    &x \ge h\\
    &\N_{x\dots+\reg_A} \not\in \mathbb{V}_{\mu}\\
    &\N_{x\dots+\reg_A} \in \mathbb{V}^*_{\mu'}
  \end{aligned}$\\
\bottomrule
\end{longtable}

Note, the term $h$ above refers to the beginning of the heap, the second major segment of memory as defined in equation \ref{eq:memlayout} as $2\mathsf{Z}_Q + Q(|\mathbf{o}|)$. If $\token{sbrk}$ instruction is invoked on a \textsc{pvm} instance which does not have such a memory layout, then $h = 0$.

\subsubsection{Instructions with Arguments of Two Registers \& One Immediate}
\begin{equation}
\begin{aligned}
  \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
  \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_B &\equiv \reg_{r_B} \,,\quad
  \reg'_B \equiv \reg'_{r_B} \\
  \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
  \immed_X &\equiv \sext_{l_X}(\de_{l_X}(\instructions_{\imath+2\dots+l_X}))
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  16&\token{store\_ind\_u8}&0&$\memwr_{\reg_B + \immed_X} = \reg_A \bmod 2^8$\\ \mrule
  29&\token{store\_ind\_u16}&0&$\memwr_{\reg_B + \immed_X \dots+ 2} = \se_2(\reg_A \bmod 2^{16})$\\ \mrule
  3&\token{store\_ind\_u32}&0&$\memwr_{\reg_B + \immed_X \dots+ 4} = \se_4(\reg_A)$\\ \mrule
  11&\token{load\_ind\_u8}&0&$\reg'_A = \mem_{\reg_B + \immed_X}$\\ \mrule
  21&\token{load\_ind\_i8}&0&$\reg'_A = \unsigned{\signedn{1}{\mem_{\reg_B + \immed_X}}}$\\ \mrule
  37&\token{load\_ind\_u16}&0&$\reg'_A = \de_2(\memr_{\reg_B + \immed_X\dots+2})$\\ \mrule
  33&\token{load\_ind\_i16}&0&$\reg'_A = \unsigned{\signedn{2}{\de_2(\memr_{\reg_B + \immed_X\dots+2})}}$\\ \mrule
  1&\token{load\_ind\_u32}&0&$\reg'_A = \de_4(\memr_{\reg_B + \immed_X\dots+4})$\\ \mrule
  2&\token{add\_imm}&0&$\reg'_A = (\reg_B + \immed_X) \bmod 2^{32}$\\ \mrule
  18&\token{and\_imm}&0&$\forall i \in \N_{32} : \bits{\reg'_A}_i = \bits{\reg_B}_i \wedge \bits{\immed_X}_i$\\ \mrule
  31&\token{xor\_imm}&0&$\forall i \in \N_{32} : \bits{\reg'_A}_i = \bits{\reg_B}_i \oplus \bits{\immed_X}_i$\\ \mrule
  49&\token{or\_imm}&0&$\forall i \in \N_{32} : \bits{\reg'_A}_i = \bits{\reg_B}_i \vee \bits{\immed_X}_i$\\ \mrule
  35&\token{mul\_imm}&0&$\reg'_A = (\reg_B \cdot \immed_X) \bmod 2^{32}$\\ \mrule
  65&\token{mul\_upper\_s\_s\_imm}&0&$\reg'_A = \unsigned{\floor{(\signed{\reg_B} \cdot \signed{\immed_X}) \div 2^{32}}}$\\ \mrule
  63&\token{mul\_upper\_u\_u\_imm}&0&$\reg'_A = \floor{(\reg_B \cdot \immed_X) \div 2^{32}}$\\ \mrule
  27&\token{set\_lt\_u\_imm}&0&$\reg'_A = \reg_B < \immed_X$\\ \mrule
  56&\token{set\_lt\_s\_imm}&0&$\reg'_A = \signed{\reg_B} < \signed{\immed_X}$\\ \mrule
  9&\token{shlo\_l\_imm}&0&$\reg'_A = (\reg_B \cdot 2^{\immed_X \bmod 32}) \bmod 2^{32}$\\ \mrule
  14&\token{shlo\_r\_imm}&0&$\reg'_A = \floor{\reg_B \div 2^{\immed_X \bmod 32}}$\\ \mrule
  25&\token{shar\_r\_imm}&0&$\reg'_A = \unsigned{\floor{\signed{\reg_B} \div 2^{\immed_X \bmod 32}}}$\\ \mrule
  40&\token{neg\_add\_imm}&0&$\reg'_A = (\immed_X + 2^{32} - \reg_B) \bmod 2^{32}$\\ \mrule
  39&\token{set\_gt\_u\_imm}&0&$\reg'_A = \reg_B > \immed_X$\\ \mrule
  61&\token{set\_gt\_s\_imm}&0&$\reg'_A = \signed{\reg_B} > \signed{\immed_X}$\\ \mrule
  75&\token{shlo\_l\_imm\_alt}&0&$\reg'_A = (\immed_X \cdot 2^{\reg_B \bmod 32}) \bmod 2^{32}$\\ \mrule
  72&\token{shlo\_r\_imm\_alt}&0&$\reg'_A = \floor{\immed_X \div 2^{\reg_B \bmod 32}}$\\ \mrule
  80&\token{shar\_r\_imm\_alt}&0&$\reg'_A = \unsigned{\floor{\signed{\immed_X} \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  85&\token{cmov\_iz\_imm}&0&$\reg'_A = \begin{cases}
    \immed_X &\when \reg_B = 0\\
    \reg_A &\otherwise
  \end{cases}$\\ \mrule
  86&\token{cmov\_nz\_imm}&0&$\reg'_A = \begin{cases}
    \immed_X &\when \reg_B \ne 0\\
    \reg_A &\otherwise
  \end{cases}$\\ \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Two Registers \& One Offset}
\begin{equation}
  \begin{aligned}
    \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
    \reg_B &\equiv \reg_{r_B} \,,\quad
    \reg'_B \equiv \reg'_{r_B} \\
    \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
    \immed_X &\equiv \imath + \signfunc{l_X}(\de_{l_X}(\instructions_{\imath+2\dots+l_X}))
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
24&\token{branch\_eq}&0&$\token{branch}(\immed_X, \reg_A = \reg_B)$\\ \mrule
30&\token{branch\_ne}&0&$\token{branch}(\immed_X, \reg_A \ne \reg_B)$\\ \mrule
47&\token{branch\_lt\_u}&0&$\token{branch}(\immed_X, \reg_A < \reg_B)$\\ \mrule
48&\token{branch\_lt\_s}&0&$\token{branch}(\immed_X, \signed{\reg_A} < \signed{\reg_B})$\\ \mrule
41&\token{branch\_ge\_u}&0&$\token{branch}(\immed_X, \reg_A \ge \reg_B)$\\ \mrule
43&\token{branch\_ge\_s}&0&$\token{branch}(\immed_X, \signed{\reg_A} \ge \signed{\reg_B})$\\
\bottomrule
\end{longtable}

\subsubsection{Instruction with Arguments of Two Registers and Two Immediates}

\begin{equation}
  \begin{aligned}
    \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
    \reg_B &\equiv \reg_{r_B} \,,\quad
    \reg'_B \equiv \reg'_{r_B} \\
    \using l_X &= \min(4, \instructions_{\imath+2} \bmod 8) \,,\quad&
    \immed_X &= \sext_{l_X}(\de_{l_X}(\instructions_{\imath+3\dots+l_X})) \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 2)) \,,\quad&
    \immed_Y &= \sext_{l_Y}(\de_{l_Y}(\instructions_{\imath+3+l_X\dots+l_Y}))
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
42&\token{load\_imm\_jump\_ind}&0&$
    \token{djump}((\reg_B + \immed_Y) \bmod 2^{32}) \ ,\qquad
    \reg_A' = \immed_X
  $\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Three Registers}
\begin{equation}
\begin{aligned}
  \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
  \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_B &\equiv \reg_{r_B} \,,\quad
  \reg'_B \equiv \reg'_{r_B} \\
  \using r_D &= \min(12, \instructions_{\imath+2}) \,,\quad&
  \reg_D &\equiv \reg_{r_D} \,,\quad
  \reg'_D \equiv \reg'_{r_D} \\
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}[t]{p{8mm} p{20mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gas$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  8&\token{add}&0&$\reg'_D = (\reg_A + \reg_B) \bmod 2^{32}$\\ \mrule
  20&\token{sub}&0&$\reg'_D = (\reg_A + 2^{32} - \reg_B) \bmod 2^{32}$\\ \mrule
  23&\token{and}&0&$\forall i \in \N_{32} : \bits{\reg'_D}_i = \bits{\reg_A}_i \wedge \bits{\reg_B}_i$\\ \mrule
  28&\token{xor}&0&$\forall i \in \N_{32} : \bits{\reg'_D}_i = \bits{\reg_A}_i \oplus \bits{\reg_B}_i$\\ \mrule
  12&\token{or}&0&$\forall i \in \N_{32} : \bits{\reg'_D}_i = \bits{\reg_A}_i \vee \bits{\reg_B}_i$\\ \mrule
  34&\token{mul}&0&$\reg'_D = (\reg_A \cdot \reg_B) \bmod 2^{32}$\\ \mrule
  67&\token{mul\_upper\_s\_s}&0&$\reg'_D = \unsigned{\floor{(\signed{\reg_A} \cdot \signed{\reg_B}) \div 2^{32}}}$\\ \mrule
  57&\token{mul\_upper\_u\_u}&0&$\reg'_D = \floor{(\reg_A \cdot \reg_B) \div 2^{32}}$\\ \mrule
  81&\token{mul\_upper\_s\_u}&0&$\reg'_D = \unsigned{\floor{(\signed{\reg_A} \cdot \reg_B) \div 2^{32}}}$\\ \mrule
  68&\token{div\_u}&0&$\reg'_D = \begin{cases}
    2^{32} - 1 &\when \reg_B = 0\\
    \floor{\reg_A \div \reg_B} &\otherwise
  \end{cases}$\\ \mrule
  64&\token{div\_s}&0&$\reg'_D = \begin{cases}
    2^{32} - 1 &\when \reg_B = 0\\
    \reg_A &\when \signed{\reg_A} = -2^{31} \wedge \signed{\reg_B} = -1\\
    \unsigned{\floor{\signed{\reg_A} \div \signed{\reg_B}}} &\otherwise
  \end{cases}$\\ \mrule
  73&\token{rem\_u}&0&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    \reg_A \bmod \reg_B &\otherwise
  \end{cases}$\\ \mrule
  70&\token{rem\_s}&0&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    0 &\when \signed{\reg_A} = -2^{31} \wedge \signed{\reg_B} = -1\\
    \unsigned{\signed{\reg_A} \bmod \signed{\reg_B}} &\otherwise
  \end{cases}$\\ \mrule
  36&\token{set\_lt\_u}&0&$\reg'_D = \reg_A < \reg_B$\\ \mrule
  58&\token{set\_lt\_s}&0&$\reg'_D = \signed{\reg_A} < \signed{\reg_B}$\\ \mrule
  55&\token{shlo\_l}&0&$\reg'_D = (\reg_A \cdot 2^{\reg_B \bmod 32}) \bmod 2^{32}$\\ \mrule
  51&\token{shlo\_r}&0&$\reg'_D = \floor{\reg_A \div 2^{\reg_B \bmod 32}}$\\ \mrule
  77&\token{shar\_r}&0&$\reg'_D = \unsigned{\floor{\signed{\reg_A} \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  83&\token{cmov\_iz}&0&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    \reg_D &\otherwise
  \end{cases}$\\ \mrule
  84&\token{cmov\_nz}&0&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B \ne 0\\
    \reg_D &\otherwise
  \end{cases}$\\
\bottomrule
\end{longtable}

\subsection{Host Call Definition}

An extended version of the \textsc{pvm} invocation which is able to progress an inner \emph{host-call} state-machine in the case of a host-call halt condition is defined as $\Psi_H$:
\begin{equation}
  \Psi_H\colon \left\{\begin{aligned}
    (\Y, \N_R, \N_G, \regs, \ram, \Omega_X, X) &\to (\{\panic, \oog, \halt\} \cup \{\fault\} \times \N_R, \Z_G, \regs, \ram, X)\\
    (\mathbf{c}, \imath, \xi, \omega, \mem, f, \mathbf{x}) &\mapsto \begin{cases}
      (\fault \times a, \imath', \xi', \omega', \mem', \mathbf{x}) &\when \bigwedge\left\{\;\begin{aligned}
        &\varepsilon = \host \times h\\[2pt]
        &\fault \times a = f(h, \xi', \omega', \mem', \mathbf{x})\\[2pt]
      \end{aligned}\right.\\[8 pt]
      \Psi_H(\mathbf{c}, \imath' + 1 + \Fskip(\imath'), \xi'', \omega'', \mem'', f, \mathbf{x}'') &\when \bigwedge\left\{\;\begin{aligned}
        &\varepsilon = \host \times h\\[2pt]
        &(\xi'', \omega'', \mem'', \mathbf{x}'') = f(h, \xi', \omega', \mem', \mathbf{x})
      \end{aligned}\right.\\[8pt]
      (\varepsilon, \imath', \xi', \omega', \mem', \mathbf{x}) &\otherwise
    \end{cases} \\
    \where (\varepsilon, \imath', \xi', \omega', \mem') &= \Psi(\mathbf{c}, \imath, \xi, \omega, \mem)\\
    \end{aligned}\right.
\end{equation}

On exit, the instruction counter $\imath'$ references the instruction \emph{which caused the exit}. Should the machine be invoked again using this instruction counter and code, then the same instruction which caused the exit would be executed. This is sensible when the instruction is one which necessarily needs re-executing such as in the case of an out-of-gas or page fault reason.

However, when the exit reason to $\Psi$ is a host-call $\host$, then the resultant instruction-counter has a value of the host-call instruction and resuming with this state would immediately exit with the same result. Re-invoking would therefore require both the post-host-call machine state \emph{and} the instruction counter value for the instruction following the one which resulted in the host-call exit reason. This is always one greater plus the relevant argument skip distance. Resuming the machine with this instruction counter will continue beyond the host-call instruction.

We use both values of instruction-counter for the definition of $\Psi_H$ since if the host-call results in a page fault we need to allow the outer environment to resolve the fault and re-try the host-call. Conversely, if we successfully transition state according to the host-call, then on resumption we wish to begin with the instruction directly following the host-call.

\subsection{Standard Program Initialization}\label{sec:standardprograminit}
The software programs which will run in each of the four instances where the \textsc{pvm} is utilized in the main document have a very typical setup pattern characteristic of an output of a compiler and linker. This means sections for program-specific read-only data, read-write (heap) data and the stack. An adjunct to this, very typical of our usage patterns is an extra read-only segment via which invocation-specific data may be passed (\ie arguments). It thus makes sense to define this properly in a single initializer function.

We thus define the standard program code format $\mathbf{p}$, which includes not only the instructions and jump table (previously represented by the term $\mathbf{c}$), but also information on the state of the \textsc{ram} and registers at program start. Given some $\mathbf{p}$ which is appropriately encoded together with some argument data $\mathbf{a}$, we can define program code $\mathbf{c}$, registers $\omega$ and \textsc{ram} $\mem$ through the standard initialization decoder function $Y$:
\begin{equation}
Y\colon\left\{\begin{aligned}
  \Y &\to (\Y, \regs, \ram)? \\
  \mathbf{p} &\mapsto x
\end{aligned}\right.
\end{equation}
Where:
\begin{align}
  &\using \mathcal{E}_3(|\mathbf{o}|) \concat \mathcal{E}_3(|\mathbf{w}|) \concat \mathcal{E}_2(z) \concat \mathcal{E}_3(s) \concat \mathbf{o} \concat \mathbf{w} \concat \mathcal{E}_4(|\mathbf{c}|) \concat \mathbf{c} = \mathbf{p}\\
  &\mathsf{Z}_P = 2^{14}\ ,\quad\mathsf{Z}_Q = 2^{16}\ ,\quad\mathsf{Z}_I = 2^{24}\\
  &\using \rnp{x \in \N} \equiv \mathsf{Z}_P\left\lceil \frac{x}{\mathsf{Z}_P} \right\rceil\quad,\qquad\rnq{x \in \N} \equiv \mathsf{Z}_Q\left\lceil \frac{x}{\mathsf{Z}_Q} \right\rceil\\
  &5\mathsf{Z}_Q + Q(|\mathbf{o}|) + Q(|\mathbf{w}| + z\mathsf{Z}_P) + Q(s) + \mathsf{Z}_I \leq 2^{32}
\end{align}
If the above cannot be satisfied, then $x = \none$, otherwise $x = (\mathbf{c}, \omega, \mem)$ with $\mathbf{c}$ as above and $\mem$, $\omega$ such that:
\begin{equation}\label{eq:memlayout}
  \forall i \in \N_R : \mem_i = \left\{\begin{alignedat}{5}
    &\tup{\is{\mathbf{V}}{\mathbf{o}_{i - \mathsf{Z}_Q}}\ts\is{\mathbf{A}}{R}} &&\ \when
        \mathsf{Z}_Q
            &\ \leq i < \ &&
                \mathsf{Z}_Q + |\mathbf{o}|\\
    &(0, R) &&\ \when
        \mathsf{Z}_Q + |\mathbf{o}|
            &\ \leq i < \ &&
                \mathsf{Z}_Q + \rnp{|\mathbf{o}|} \\
    &(\mathbf{w}_{i - (2\mathsf{Z}_Q + \rnq{|\mathbf{o}|})}, W) &&\ \when
        2\mathsf{Z}_Q + \rnq{|\mathbf{o}|}
            &\ \leq i < \ &&
                2\mathsf{Z}_Q + \rnq{|\mathbf{o}|} + |\mathbf{w}|\\
    &(0, W) &&\ \when
        2\mathsf{Z}_Q + \rnq{|\mathbf{o}|} + |\mathbf{w}|
            &\ \leq i < \ &&
                2\mathsf{Z}_Q + \rnq{|\mathbf{o}|} + \rnp{|\mathbf{w}|} + z\mathsf{Z}_P\\
    &(0, W) &&\ \when
        2^{32} - 2\mathsf{Z}_Q - \mathsf{Z}_I - \rnp{s}
            &\ \leq i < \ &&
                2^{32} - 2\mathsf{Z}_Q - \mathsf{Z}_I\\
    &(\mathbf{a}_{i - (2^{32} - \mathsf{Z}_Q - \mathsf{Z}_I)}, R) &&\ \when
        2^{32} - \mathsf{Z}_Q - \mathsf{Z}_I
            &\ \leq i < \ &&
                2^{32} - \mathsf{Z}_Q - \mathsf{Z}_I + |\mathbf{a}|\\
    &(0, R) &&\ \when
        2^{32} - \mathsf{Z}_Q - \mathsf{Z}_I + |\mathbf{a}|
            &\ \leq i < \ &&
                2^{32} - \mathsf{Z}_Q - \mathsf{Z}_I + \rnp{|\mathbf{a}|}\\
    &(0, \none) &&\otherwise&&&
  \end{alignedat}\right.\\
\end{equation}
\begin{equation}
  \forall i \in \N_{16} : \omega_i = \begin{cases}
      2^{32} - 2^{16} &\when i = 1\\
      2^{32} - 2\mathsf{Z}_Q - \mathsf{Z}_I &\when i = 2\\
      2^{32} - \mathsf{Z}_Q - \mathsf{Z}_I &\when i = 10\\
      |\mathbf{a}|&\when i = 11\\
      0 &\otherwise
    \end{cases}
\end{equation}

\subsection{Argument Invocation Definition}

The four instances where the \textsc{pvm} is utilized each expect to be able to pass argument data in and receive some return data back. We thus define the common \textsc{pvm} program-argument invocation function $\Psi_M$:
\begin{align}
  \Psi_M&\colon \left\{\begin{aligned}
    (\Y, \N, \N_G, \Y_{:\mathsf{Z}_I}, \Omega_X, X) &\to ((\N_G, \Y) \cup \{\panic, \oog\}, X)\\
    (\mathbf{p}, \imath, \xi, \mathbf{a}, f, \mathbf{x}) &\mapsto \begin{cases}
      (\panic, \mathbf{x}) &\when Y(\mathbf{p}) = \none\\
      R(\Psi_H(\mathbf{c}, \imath, \xi, \omega, \mem, f, \mathbf{x})) &\when Y(\mathbf{p}) = (\mathbf{c}, \omega, \mem)
    \end{cases}
  \end{aligned}\right.\\
  \where R&\colon (\varepsilon, \imath', \xi', \omega', \mem', \mathbf{x}) \mapsto \begin{cases}
    (\oog, \mathbf{x}) &\when \varepsilon = \oog \\
    ((\xi', \mu'_{\omega'_{10}\dots+\omega'_{11}}), \mathbf{x}) &\when \varepsilon = \halt \wedge \mathbb{Z}_{\omega'_{10}\dots+\omega'_{11}} \subset \mathbb{V}_{\mem'} \\
    ((\xi', []), \mathbf{x}) &\when \varepsilon = \halt \wedge \mathbb{Z}_{\omega'_{10}\dots+\omega'_{11}} \not\subset \mathbb{V}_{\mem'} \\
    (\panic, \mathbf{x}) &\otherwise \\
  \end{cases}
\end{align}
