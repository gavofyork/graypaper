\section{Polkadot Virtual Machine}\label{sec:virtualmachine}

%TODO: #446 First 64KB of memory is always inaccessible.

\subsection{Basic Definition}
\newcommand*{\instr}[1]{\text{{\small \texttt{#1}}}}
\newcommand*{\regs}{\sequence[13]{\pvmreg}}
\newcommand*{\reg}{{\registers}}
\newcommand*{\mem}{{\memory}}
\newcommand*{\memr}{\cyclic{\mem}}
\newcommand*{\memwr}{\cyclic{\mem'}}
\newcommand*{\rnp}[1]{P(#1)}
\newcommand*{\rnq}[1]{Z(#1)}
\newcommand*{\continue}{\blacktriangleright}
\newcommand*{\gascost}{\gascounter_\Delta}
\newcommand*{\instrlen}{\ell}
\newcommand*{\revbitsfunc}[1]{\overleftarrow{\fnoctetstobits}_{#1}}
\newcommand*{\revunbitsfunc}[1]{\revbitsfunc{#1}^{-1}}
\newcommand*{\bitsfunc}[1]{\fnoctetstobits_{#1}}
\newcommand*{\unbitsfunc}[1]{\bitsfunc{#1}^{-1}}
\newcommand*{\bits}[1]{\bitsn{8}{#1}}
\newcommand*{\unbits}[1]{\unbitsn{8}{#1}}
\newcommand*{\bitsn}[2]{\bitsfunc{#1}(#2)}
\newcommand*{\unbitsn}[2]{\unbitsfunc{#1}(#2)}
\newcommand*{\RA}{\token{RA}}
\newcommand*{\SP}{\token{SP}}
\newcommand*{\T}{\token{T}}
\renewcommand*{\S}{\token{S}}
\newcommand*{\A}{\token{A}}
\newcommand*{\basicblocks}{\varpi}
\newcommand*{\instructions}{\zeta}
\newcommand*{\immed}{\nu}
\newcommand*{\deblob}{\text{deblob}}
\newcommand*{\smod}{\text{smod}}
\newcommand*{\rtz}{\text{rtz}}

We declare the general \textsc{pvm} function $\Psi$. We assume a single-step invocation function define $\Psi_1$ and define the full \textsc{pvm} recursively as a sequence of such mutations up until the single-step mutation results in a halting condition. We additionally define the function $\deblob$ which extracts the instruction data, opcode bitmask and dynamic jump table from a program blob:
\begin{align}
  \Psi&\colon \abracegroup{
    \tuple{\blob, \pvmreg, \gas, \regs, \ram} &\to \tuple{\set{\halt, \panic, \oog} \cup \set{\fault, \host} \times \pvmreg, \pvmreg, \signedgas, \regs, \ram}\\
    \tup{\mathbf{p}, \imath, \gascounter, \registers, \mem} &\mapsto \begin{cases}
      \Psi(\mathbf{p}, \imath', \gascounter', \registers', \mem') &\when \varepsilon = \continue\\
      \tup{\oog, \imath', \gascounter', \registers', \mem'} &\when \gascounter' < 0\\
      \tup{\varepsilon, 0, \gascounter', \registers', \mem'} &\when \varepsilon \in \set{ \panic, \halt }\\
      \tup{\varepsilon, \imath', \gascounter', \registers', \mem'} &\otherwise
    \end{cases} \\
    \where \tup{\varepsilon, \imath', \gascounter', \registers', \mem'} &= \begin{cases}
      \Psi_1(\mathbf{c}, \mathbf{k}, \mathbf{j}, \imath, \gascounter, \registers, \mem) &\when \tup{\mathbf{c}, \mathbf{k}, \mathbf{j}} = \deblob(\mathbf{p}) \\
      \tup{\panic, \imath, \gascounter, \registers, \mem} &\otherwise
    \end{cases}
  }\\
  \deblob&\colon\abracegroup{
    \blob &\to \tuple{\blob, \bitstring, \sequence{\pvmreg}} \cup \error \\
    \mathbf{p} &\mapsto \begin{cases}
      \tup{\mathbf{c}, \mathbf{k}, \mathbf{j}} &\when \exists!\,\mathbf{c}, \mathbf{k}, \mathbf{j} : \mathbf{p} = \encode{\len{\mathbf{j}}} \concat \encode[1]{z} \concat \encode{\len{\mathbf{c}}} \concat \encode[z]{\mathbf{j}} \concat \encode{\mathbf{c}} \concat \encode{\mathbf{k}}\,,\ \len{\mathbf{k}} = \len{\mathbf{c}} \\
      \error &\otherwise
    \end{cases} \\
  }
\end{align}

The \textsc{pvm} exit reason $\varepsilon \in \set{\halt, \panic, \oog} \cup \set{\fault, \host} \times \pvmreg$ may be one of regular halt $\halt$, panic $\panic$ or out-of-gas $\oog$, or alternatively a host-call $\host$, in which the host-call identifier is associated, or page-fault $\fault$ in which case the address into \textsc{ram} is associated.

\subsection{Instructions, Opcodes and Skip-distance}

The program blob $\mathbf{p}$ is split into a series of octets which make up the \emph{instruction data} $\mathbf{c}$ and the \emph{opcode bitmask} $\mathbf{k}$ as well as the \emph{dynamic jump table}, $\mathbf{j}$. The former two imply an instruction sequence, and by extension a \emph{basic-block sequence}, itself a sequence of indices of the instructions which follow a \emph{block-termination} instruction.

The latter, dynamic jump table, is a sequence of indices into the instruction data blob and is indexed into when dynamically-computed jumps are taken. It is encoded as a sequence of natural numbers (i.e. non-negative integers) each encoded with the same length in octets. This length, term $z$ above, is itself encoded prior.

The \textsc{pvm} counts instructions in octet terms (rather than in terms of instructions) and it is thus necessary to define which octets represent the beginning of an instruction, \ie the opcode octet, and which do not. This is the purpose of $\mathbf{k}$, the instruction-opcode bitmask. We assert that the length of the bitmask is equal to the length of the instruction blob.

\newcommand{\Fskip}{\text{skip}}

We define the Skip function $\Fskip$ which provides the number of octets, minus one, to the next instruction's opcode, given the index of instruction's opcode index into $\mathbf{c}$ (and by extension $\mathbf{k}$):
\begin{equation}
  \Fskip\colon\abracegroup{
    \N &\to \N\\
    i &\mapsto \min(24,\ j \in \N : \tup{\mathbf{k} \concat \sq{1, 1, \dots}}_{i + 1 + j} = 1)
  }
\end{equation}

The Skip function appends $\mathbf{k}$ with a sequence of set bits in order to ensure a well-defined result for the final instruction $\Fskip(\len{\mathbf{c}} - 1)$.

Given some instruction-index $i$, its opcode is readily expressed as $\mathbf{c}_i$ and the distance in octets to move forward to the next instruction is $1 + \Fskip(i)$. However, each instruction's ``length'' (defined as the number of contiguous octets starting with the opcode which are needed to fully define the instruction's semantics) is left implicit though limited to being at most 16.

We define $\instructions$ as being equivalent to the instructions $\mathbf{c}$ except with an indefinite sequence of zeroes suffixed to ensure that no out-of-bounds access is possible. This effectively defines any otherwise-undefined arguments to the final instruction and ensures that a trap will occur if the program counter passes beyond the program code. Formally:
\begin{equation}\label{eq:instructions}
  \instructions \equiv \mathbf{c} \concat \sq{0, 0, \dots}
\end{equation}

\subsection{Basic Blocks and Termination Instructions}

Instructions of the following opcodes are considered basic-block termination instructions; other than $\token{trap}$ \& $\token{fallthrough}$, they correspond to instructions which may define the instruction-counter to be something other than its prior value plus the instruction's skip amount:
\begin{itemize}
  \item Trap and fallthrough: $\token{trap}$
  , $\token{fallthrough}$
  \item Jumps: $\token{jump}$
  , $\token{jump\_ind}$
  \item Load-and-Jumps: $\token{load\_imm\_jump}$
  , $\token{load\_imm\_jump\_ind}$
  \item Branches: $\token{branch\_eq}$
  , $\token{branch\_ne}$
  , $\token{branch\_ge\_u}$
  , $\token{branch\_ge\_s}$
  , $\token{branch\_lt\_u}$
  , $\token{branch\_lt\_s}$
  , $\token{branch\_eq\_imm}$
  , $\token{branch\_ne\_imm}$
  \item Immediate branches: $\token{branch\_lt\_u\_imm}$
  , $\token{branch\_lt\_s\_imm}$
  , $\token{branch\_le\_u\_imm}$
  , $\token{branch\_le\_s\_imm}$
  , $\token{branch\_ge\_u\_imm}$
  , $\token{branch\_ge\_s\_imm}$
  , $\token{branch\_gt\_u\_imm}$
  , $\token{branch\_gt\_s\_imm}$
\end{itemize}

We denote this set, as opcode indices rather than names, as $T$, which is a subset of all valid opcode indices $U$. We define the instruction opcode indices denoting the beginning of basic-blocks as $\basicblocks$:
\begin{equation}
  \basicblocks \equiv \left(\set{0} \cup \set{\build{n + 1 + \Fskip(n)}{n \in \Nmax{\len{\mathbf{c}}} \wedge \mathbf{k}\sub{n} = 1 \wedge \mathbf{c}\sub{n} \in T}}\right) \cap \set{\build{n}{\mathbf{k}\sub{n} = 1 \wedge \mathbf{c}\sub{n} \in U}}
\end{equation}

\subsection{Single-Step State Transition}

We must now define the single-step \textsc{pvm} state-transition function $\Psi_1$:
\begin{equation}
  \Psi_1\colon \abracegroup{
    \tuple{\blob, \bitstring, \sequence{\pvmreg}, \pvmreg, \gas, \regs, \ram} &\to \tuple{\set{\panic, \halt, \continue } \cup \set{\fault, \host} \times \pvmreg, \pvmreg, \signedgas, \regs, \ram}\\
    \tup{\mathbf{c}, \mathbf{k}, \mathbf{j}, \imath, \gascounter, \registers, \mem} &\mapsto \tup{\varepsilon, \imath', \gascounter', \registers', \mem'}
  }
\end{equation}

We define $\varepsilon$ together with the posterior values (denoted as prime) of each of the items of the machine state as being in accordance with the table below.

%We alias the registers $\registers$ to their \textsc{risc-v} specification name:
%\begin{equation}
%  \tup{\RA, \SP, \T_0, \T_1, \T_2, \S_0, \S_1, \A_0, \A_1, \A_2, \A_3, \A_4, \A_5} \equiv \registers,\qquad
%  \tup{\RA', \SP', \T_0', \T_1', \T_2', \S_0', \S_1', \A_0', \A_1', \A_2', \A_3', \A_4', \A_5'} \equiv \registers'
%\end{equation}

In general, when transitioning machine state for an instruction a number of conditions hold true and instructions are defined essentially by their exceptions to these rules. Specifically, the machine does not halt, the instruction counter increments by one, the gas remaining is reduced by the amount corresponding to the instruction type and \textsc{ram} \& registers are unchanged. Formally:
\begin{equation}
  \varepsilon = \continue,\quad \imath' = \imath + 1 + \Fskip(\imath),\quad \gascounter' = \gascounter - \gascost,\quad \registers' = \registers,\quad\mem' = \mem \text{ except as indicated }
\end{equation}

During the course of executing instructions, \textsc{ram} may be accessed. When an index of \textsc{ram} below $2^{16}$ is required, the machine always panics immediately without further changes to its state regardless of the apparent (in)accessibility of the value. Otherwise, should the given index of \textsc{ram} not be accessible then machine state remains unchanged and the exit reason is a fault with the lowest inaccessible \emph{page address} to be read. Similarly, where \textsc{ram} must be mutated and yet mutable access is not possible, then machine state is unchanged, and the exit reason is a fault with the lowest page address to be written which is inaccessible.

Formally, let $\mathbf{r}$ and $\mathbf{w}$ be the set of indices by which $\mem$ must be subscripted for inspection and mutation respectively in order to calculate the result of $\Psi_1$. We define the memory-access exceptional execution state $\varepsilon^\mu$ which shall, if not $\continue$, singly effect the returned return of $\Psi_1$ as following:
\begin{align}
  \using \mathbf{x} &= \set{\build{x}{x \in \mathbf{r} \wedge x \bmod 2^{32} \not\in \readable\mem\ \vee\ x \in \mathbf{w} \wedge x \bmod 2^{32} \not\in \writable\mem}} \\
  \varepsilon^\mu &= \begin{cases}
    \continue &\when \mathbf{x} = \emset \\
    \panic &\when \min(\mathbf{x}) \bmod 2^{32} < 2^{16} \\
    \fault \times \Cpvmpagesize\floor{\min(\mathbf{x}) \bmod 2^{32} \div \Cpvmpagesize} &\otherwise
  \end{cases}
\end{align}

We define signed/unsigned transitions for various octet widths:
\begin{align}
  \label{eq:signedfunc}
  \signfunc{n \in \N}&\colon\abracegroup{
    \Nbits{8n} &\to \Z_{-2^{8n-1}\dots2^{8n-1}}\\
    a &\mapsto \begin{cases}
      a &\when a < 2^{8n-1} \\
      a -\ 2^{8n} &\otherwise
    \end{cases}
  }\\
  \unsignfunc{n \in \N}&\colon\abracegroup{
    \Z_{-2^{8n-1}\dots2^{8n-1}} &\to \Nbits{8n}\\
    a &\mapsto (2^{8n} + a) \bmod 2^{8n}
  }\\
  \label{eq:bitsfunc}
  \bitsfunc{n\in\N}&\colon\abracegroup{
    \Nbits{8n} &\to \bitstring[8n]\\
    x &\mapsto \mathbf{y}: \forall i \in \Nmax{8n} : \mathbf{y}\subb{i} \Leftrightarrow \ffrac{x}{2^i}\bmod 2
  }\\
  \unbitsfunc{n\in\N}&\colon\abracegroup{
    \bitstring[8n] &\to \Nbits{8n}\\
    \mathbf{x} &\mapsto y: \sum_{i \in \Nmax{8n}} \mathbf{x}\sub{i} \cdot 2^i
  }\\
  \label{eq:revbitsfunc}
  \revbitsfunc{n\in\N}&\colon\abracegroup{
    \Nbits{8n} &\to \bitstring[8n]\\
    x &\mapsto \mathbf{y}: \forall i \in \Nmax{8n} : \mathbf{y}[8n - 1 - i] \Leftrightarrow \ffrac{x}{2^i}\bmod 2
  }\\
  \revunbitsfunc{n\in\N}&\colon\abracegroup{
    \bitstring[8n] &\to \Nbits{8n}\\
    \mathbf{x} &\mapsto y: \sum_{i \in \Nmax{8n}} \mathbf{x}\sub{8n - 1 - i} \cdot 2^i
  }
\end{align}

Immediate arguments are encoded in little-endian format with the most-significant bit being the sign bit. They may be compactly encoded by eliding more significant octets. Elided octets are assumed to be zero if the \textsc{msb} of the value is zero, and 255 otherwise. This allows for compact representation of both positive and negative encoded values. We thus define the signed extension function operating on an input of $n$ octets as $\fnsext{n}$:
\begin{align}\label{eq:signedextension}
  \fnsext{n \in \set{0, 1, 2, 3, 4, 8}}\colon\abracegroup{
    \Nbits{8n} &\to \pvmreg\\
    x &\mapsto x + \ffrac{x}{2^{8n-1}}(2^{64}-2^{8n})
  }
\end{align}

Any alterations of the program counter stemming from a static jump, call or branch must be to the start of a basic block or else a panic occurs. Hypotheticals are not considered. Formally:
\begin{equation}
  \token{branch}(b, C) \implies \tup{\varepsilon, \imath'} = \begin{cases}
    \tup{\continue, \imath} &\when \lnot C \\
    \tup{\panic, \imath} &\otherwhen b \not\in \basicblocks \\
    \tup{\continue, b} &\otherwise
  \end{cases}
\end{equation}

Jumps whose next instruction is dynamically computed must use an address which may be indexed into the jump-table $\mathbf{j}$. Through a quirk of tooling\footnote{The popular code generation backend \textsc{llvm} requires and assumes in its code generation that dynamically computed jump destinations always have a certain memory alignment. Since at present we depend on this for our tooling, we must acquiesce to its assumptions.}, we define the dynamic address required by the instructions as the jump table index incremented by one and then multiplied by our jump alignment factor $\Cpvmdynaddralign = 2$.

As with other irregular alterations to the program counter, target code index must be the start of a basic block or else a panic occurs. Formally:
\begin{equation}\label{eq:jumptablealignment}
  \token{djump}(a) \implies \tup{\varepsilon, \imath'} = \begin{cases}
    \tup{\halt, \imath} &\when a = 2^{32} - 2^{16}\\
    \tup{\panic, \imath} &\otherwhen a = 0 \vee a > \len{\mathbf{j}}\cdot\Cpvmdynaddralign \vee a \bmod \Cpvmdynaddralign \ne 0 \vee \mathbf{j}_{(\nicefrac{a}{\Cpvmdynaddralign}) - 1} \not\in \basicblocks \\
    (\continue, \mathbf{j}_{(\nicefrac{a}{\Cpvmdynaddralign}) - 1}) &\otherwise
  \end{cases}
\end{equation}

\subsection{Instruction Tables}\label{sec:instructiontables}

Only instructions which are defined in the following tables and whose opcode has its corresponding bit set in the bitmask are considered valid, otherwise the instruction behaves as-if its opcode was equal to zero. Assuming $U$ denotes all valid opcode indices, formally:
\begin{equation}
  \text{opcode}\colon\abracegroup{
    \N &\to \N\\
    n &\mapsto \begin{cases}
    \mathbf{c}\sub{n} &\when \mathbf{k}\sub{n} = 1 \wedge \mathbf{c}\sub{n} \in U \\
    0 &\otherwise
    \end{cases}
  }
\end{equation}

We assume the skip length $\ell$ is well-defined:
\begin{equation}
  \ell \equiv \Fskip(\imath)
\end{equation}

\subsubsection{Instructions without Arguments}

\newcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{20mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  0&\token{trap}&1&$\varepsilon = \panic$\\
  \mrule
  1&\token{fallthrough}&1&\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Immediate}
\begin{equation}
\begin{aligned}
  \using l_X = \min(4, \ell) \,,\quad
  \immed_X \equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+1}{l_X}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  10&\token{ecalli}&1&$\varepsilon = \host \times \immed_X$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register and One Extended Width Immediate}
\begin{equation}
  \using r_A = \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad
  \reg'_A \equiv \reg'_{r_A} \,,\quad
  \immed_X \equiv \decode[8]{\instructions\subrange{\imath+2}{8}}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  20&\token{load\_imm\_64}&1&$\reg'_A = \immed_X$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Two Immediates}
\begin{equation}
\begin{aligned}
    \using l_X &= \min(4, \instructions_{\imath+1} \bmod 8) \,,\quad&
    \immed_X &\equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}} \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
    \immed_Y &\equiv \sext{l_Y}{\decode[l_Y]{\instructions\subrange{\imath+2+l_X}{l_Y}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  30&\token{store\_imm\_u8}&1&$\memwr_{\immed_X} = \immed_Y \bmod 2^8 $\\ \mrule
  31&\token{store\_imm\_u16}&1&$\memwr\subrange{\immed_X}{2} = \encode[2]{\immed_Y \bmod 2^{16}}$\\ \mrule
  32&\token{store\_imm\_u32}&1&$\memwr\subrange{\immed_X}{4} = \encode[4]{\immed_Y \bmod 2^{32}}$\\ \mrule
  33&\token{store\_imm\_u64}&1&$\memwr\subrange{\immed_X}{8} = \encode[8]{\immed_Y}$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Offset}
\begin{equation}
\begin{aligned}
  \using l_X = \min(4, \ell) \,,\quad
  \immed_X \equiv \imath + \signfunc{l_X}(\decode[l_X]{\instructions\subrange{\imath+1}{l_X}})
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  40&\token{jump}&1&$\token{branch}(\immed_X, \top)$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register \& One Immediate}
\begin{equation}
\begin{aligned}
    \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
    \immed_X &\equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  50&\token{jump\_ind}&1&$\token{djump}((\reg_A + \immed_X) \bmod 2^{32})$\\ \mrule
  51&\token{load\_imm}&1&$\reg'_A = \immed_X$\\ \mrule
  52&\token{load\_u8}&1&$\reg'_A = \memr_{\immed_X}$\\ \mrule
  53&\token{load\_i8}&1&$\reg'_A = \sext{1}{\memr_{\immed_X}}$\\ \mrule
  54&\token{load\_u16}&1&$\reg'_A = \decode[2]{\memr\subrange{\immed_X}{2}}$\\ \mrule
  55&\token{load\_i16}&1&$\reg'_A = \sext{2}{\decode[2]{\memr\subrange{\immed_X}{2}}}$\\ \mrule
  56&\token{load\_u32}&1&$\reg'_A = \decode[4]{\memr\subrange{\immed_X}{4}}$\\ \mrule
  57&\token{load\_i32}&1&$\reg'_A = \sext{4}{\decode[4]{\memr\subrange{\immed_X}{4}}}$\\ \mrule
  58&\token{load\_u64}&1&$\reg'_A = \decode[8]{\memr\subrange{\immed_X}{8}}$\\ \mrule
  59&\token{store\_u8}&1&$\memwr_{\immed_X} = \reg_A \bmod 2^8$\\ \mrule
  60&\token{store\_u16}&1&$\memwr\subrange{\immed_X}{2} = \encode[2]{\reg_A \bmod 2^{16}}$\\ \mrule
  61&\token{store\_u32}&1&$\memwr\subrange{\immed_X}{4} = \encode[4]{\reg_A \bmod 2^{32}}$\\ \mrule
  62&\token{store\_u64}&1&$\memwr\subrange{\immed_X}{8} = \encode[8]{\reg_A}$\\
\bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register \& Two Immediates}
\begin{equation}
\begin{aligned}
    \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using l_X &= \min(4, \ffrac{\instructions_{\imath+1}}{16} \bmod 8) \,,\quad&
    \immed_X &= \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}} \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
    \immed_Y &= \sext{l_Y}{\decode[l_Y]{\instructions\subrange{\imath+2+l_X}{l_Y}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  70&\token{store\_imm\_ind\_u8}&1&$\memwr_{\reg_A + \immed_X} = \immed_Y \bmod 2^8$\\ \mrule
  71&\token{store\_imm\_ind\_u16}&1&$\memwr\subrange{\reg_A + \immed_X}{2} = \encode[2]{\immed_Y \bmod 2^{16}}$\\ \mrule
  72&\token{store\_imm\_ind\_u32}&1&$\memwr\subrange{\reg_A + \immed_X}{4} = \encode[4]{\immed_Y \bmod 2^{32}}$\\ \mrule
  73&\token{store\_imm\_ind\_u64}&1&$\memwr\subrange{\reg_A + \immed_X}{8} = \encode[8]{\immed_Y}$\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of One Register, One Immediate and One Offset}
\begin{equation}
  \begin{aligned}
      \using r_A &= \min(12, \instructions_{\imath+1} \bmod 16) \,,\quad&
      \reg_A &\equiv \reg_{r_A} \,,\quad
      \reg'_A \equiv \reg'_{r_A} \\
      \using l_X &= \min(4, \ffrac{\instructions_{\imath+1}}{16} \bmod 8) \,,\quad&
      \immed_X &= \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}} \\
      \using l_Y &= \min(4, \max(0, \ell - l_X - 1)) \,,\quad&
      \immed_Y &= \imath + \signfunc{l_Y}(\decode[l_Y]{\instructions\subrange{\imath+2+l_X}{l_Y}})
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  80&\token{load\_imm\_jump}&1&$\token{branch}(\immed_Y, \top)\ ,\qquad \reg_A' = \immed_X$\\ \mrule
  81&\token{branch\_eq\_imm}&1&$\token{branch}(\immed_Y, \reg_A = \immed_X)$\\ \mrule
  82&\token{branch\_ne\_imm}&1&$\token{branch}(\immed_Y, \reg_A \ne \immed_X)$\\ \mrule
  83&\token{branch\_lt\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A < \immed_X)$\\ \mrule
  84&\token{branch\_le\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A \le \immed_X)$\\ \mrule
  85&\token{branch\_ge\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A \ge \immed_X)$\\ \mrule
  86&\token{branch\_gt\_u\_imm}&1&$\token{branch}(\immed_Y, \reg_A > \immed_X)$\\ \mrule
  87&\token{branch\_lt\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} < \signed{\immed_X})$\\ \mrule
  88&\token{branch\_le\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} \le \signed{\immed_X})$\\ \mrule
  89&\token{branch\_ge\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} \ge \signed{\immed_X})$\\ \mrule
  90&\token{branch\_gt\_s\_imm}&1&$\token{branch}(\immed_Y, \signed{\reg_A} > \signed{\immed_X})$\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Two Registers}
\begin{equation}
\begin{aligned}
  \using r_D &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_D &\equiv \reg_{r_D} \,,\quad
  \reg'_D \equiv \reg'_{r_D} \\
  \using r_A &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{32mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  100&\token{move\_reg}&1&$\reg'_D = \reg_A$\\ \mrule
  101&\token{sbrk}&1&$\begin{aligned}
    \reg'_D \equiv &\min(x \in \pvmreg): \\
    &x \ge h\\
    &\Nrange{x}{\reg_A} \not\subseteq \readable{\memory}\\
    &\Nrange{x}{\reg_A} \subseteq \writable{\memory'}
  \end{aligned}$\\ \mrule
  102&\token{count\_set\_bits\_64}&1&$\displaystyle\reg'_D = \sum_{i = 0}^{63}\bitsfunc{8}(\reg_A)\sub{i}$\\ \mrule
  103&\token{count\_set\_bits\_32}&1&$\displaystyle\reg'_D = \sum_{i = 0}^{31}\bitsfunc{4}(\reg_A \bmod 2^{32})\sub{i}$\\ \mrule
  104&\token{leading\_zero\_bits\_64}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{65})\ \where \sum_{i = 0}^{i < n} \revbitsfunc{8}(\reg_A)\sub{i} = 0$\\ \mrule
  105&\token{leading\_zero\_bits\_32}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{33})\ \where \sum_{i = 0}^{i < n} \revbitsfunc{4}(\reg_A \bmod 2^{32})\sub{i} = 0$\\ \mrule
  106&\token{trailing\_zero\_bits\_64}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{65})\ \where \sum_{i = 0}^{i < n} \bitsfunc{8}(\reg_A)\sub{i} = 0$\\ \mrule
  107&\token{trailing\_zero\_bits\_32}&1&$\displaystyle\reg'_D = \max(n \in \Nmax{33})\ \where \sum_{i = 0}^{i < n} \bitsfunc{4}(\reg_A \bmod 2^{32})\sub{i} = 0$\\ \mrule
  108&\token{sign\_extend\_8}&1&$\reg'_D = \unsigned{\signedn{1}{\reg_A \bmod 2^8}}$\\ \mrule
  109&\token{sign\_extend\_16}&1&$\reg'_D = \unsigned{\signedn{2}{\reg_A \bmod 2^{16}}}$\\ \mrule
  110&\token{zero\_extend\_16}&1&$\reg'_D = \reg_A \bmod 2^{16}$\\ \mrule
  111&\token{reverse\_bytes}&1&$\forall i \in \N_8 : \encode[8]{\reg'_D}\sub{i} = \encode[8]{\reg_A}_{7-i}$\\
%  10X&\token{}&1&$\reg'_D = ...$\\ \mrule
\bottomrule
\end{longtable}

Note, the term $h$ above refers to the beginning of the heap, the second major section of memory as defined in equation \ref{eq:memlayout} as $2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}}$. If $\token{sbrk}$ instruction is invoked on a \textsc{pvm} instance which does not have such a memory layout, then $h = 0$.

\subsubsection{Instructions with Arguments of Two Registers \& One Immediate}
\begin{equation}
\begin{aligned}
  \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
  \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_B &\equiv \reg_{r_B} \,,\quad
  \reg'_B \equiv \reg'_{r_B} \\
  \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
  \immed_X &\equiv \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+2}{l_X}}}
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{35mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  120&\token{store\_ind\_u8}&1&$\memwr_{\reg_B + \immed_X} = \reg_A \bmod 2^8$\\ \mrule
  121&\token{store\_ind\_u16}&1&$\memwr\subrange{\reg_B + \immed_X}{2} = \encode[2]{\reg_A \bmod 2^{16}}$\\ \mrule
  122&\token{store\_ind\_u32}&1&$\memwr\subrange{\reg_B + \immed_X}{4} = \encode[4]{\reg_A \bmod 2^{32}}$\\ \mrule
  123&\token{store\_ind\_u64}&1&$\memwr\subrange{\reg_B + \immed_X}{8} = \encode[8]{\reg_A}$\\ \mrule
  124&\token{load\_ind\_u8}&1&$\reg'_A = \memr_{\reg_B + \immed_X}$\\ \mrule
  125&\token{load\_ind\_i8}&1&$\reg'_A = \unsigned{\signedn{1}{\memr_{\reg_B + \immed_X}}}$\\ \mrule
  126&\token{load\_ind\_u16}&1&$\reg'_A = \decode[2]{\memr\subrange{\reg_B + \immed_X}{2}}$\\ \mrule
  127&\token{load\_ind\_i16}&1&$\reg'_A = \unsigned{\signedn{2}{\decode[2]{\memr\subrange{\reg_B + \immed_X}{2}}}}$\\ \mrule
  128&\token{load\_ind\_u32}&1&$\reg'_A = \decode[4]{\memr\subrange{\reg_B + \immed_X}{4}}$\\ \mrule
  129&\token{load\_ind\_i32}&1&$\reg'_A = \unsigned{\signedn{4}{\decode[4]{\memr\subrange{\reg_B + \immed_X}{4}}}}$\\ \mrule
  130&\token{load\_ind\_u64}&1&$\reg'_A = \decode[8]{\memr\subrange{\reg_B + \immed_X}{8}}$\\ \mrule
  131&\token{add\_imm\_32}&1&$\reg'_A = \sext{4}{(\reg_B + \immed_X) \bmod 2^{32}}$\\ \mrule
  132&\token{and\_imm}&1&$\forall i \in \Nmax{64} : \bits{\reg'_A}\sub{i} = \bits{\reg_B}\sub{i} \wedge \bits{\immed_X}\sub{i}$\\ \mrule
  133&\token{xor\_imm}&1&$\forall i \in \Nmax{64} : \bits{\reg'_A}\sub{i} = \bits{\reg_B}\sub{i} \oplus \bits{\immed_X}\sub{i}$\\ \mrule
  134&\token{or\_imm}&1&$\forall i \in \Nmax{64} : \bits{\reg'_A}\sub{i} = \bits{\reg_B}\sub{i} \vee \bits{\immed_X}\sub{i}$\\ \mrule
  135&\token{mul\_imm\_32}&1&$\reg'_A = \sext{4}{(\reg_B \cdot \immed_X) \bmod 2^{32}}$\\ \mrule
  136&\token{set\_lt\_u\_imm}&1&$\reg'_A = \reg_B < \immed_X$\\ \mrule
  137&\token{set\_lt\_s\_imm}&1&$\reg'_A = \signed{\reg_B} < \signed{\immed_X}$\\ \mrule
  138&\token{shlo\_l\_imm\_32}&1&$\reg'_A = \sext{4}{(\reg_B \cdot 2^{\immed_X \bmod 32}) \bmod 2^{32}}$\\ \mrule
  139&\token{shlo\_r\_imm\_32}&1&$\reg'_A = \sext{4}{\floor{\reg_B \bmod 2^{32} \div 2^{\immed_X \bmod 32}}}$\\ \mrule
  140&\token{shar\_r\_imm\_32}&1&$\reg'_A = \unsigned{\floor{\signedn{4}{\reg_B \bmod 2^{32} } \div 2^{\immed_X \bmod 32}}}$\\ \mrule
  141&\token{neg\_add\_imm\_32}&1&$\reg'_A = \sext{4}{(\immed_X + 2^{32} - \reg_B) \bmod 2^{32}}$\\ \mrule
  142&\token{set\_gt\_u\_imm}&1&$\reg'_A = \reg_B > \immed_X$\\ \mrule
  143&\token{set\_gt\_s\_imm}&1&$\reg'_A = \signed{\reg_B} > \signed{\immed_X}$\\ \mrule
  144&\token{shlo\_l\_imm\_alt\_32}&1&$\reg'_A = \sext{4}{(\immed_X \cdot 2^{\reg_B \bmod 32}) \bmod 2^{32}}$\\ \mrule
  145&\token{shlo\_r\_imm\_alt\_32}&1&$\reg'_A = \sext{4}{\floor{\immed_X \bmod 2^{32} \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  146&\token{shar\_r\_imm\_alt\_32}&1&$\reg'_A = \unsigned{\floor{\signedn{4}{\immed_X \bmod 2^{32}} \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  147&\token{cmov\_iz\_imm}&1&$\reg'_A = \begin{cases}
    \immed_X &\when \reg_B = 0\\
    \reg_A &\otherwise
  \end{cases}$\\ \mrule
  148&\token{cmov\_nz\_imm}&1&$\reg'_A = \begin{cases}
    \immed_X &\when \reg_B \ne 0\\
    \reg_A &\otherwise
  \end{cases}$\\ \mrule
  149&\token{add\_imm\_64}&1&$\reg'_A = (\reg_B + \immed_X) \bmod 2^{64}$\\ \mrule
  150&\token{mul\_imm\_64}&1&$\reg'_A = (\reg_B \cdot \immed_X) \bmod 2^{64}$\\ \mrule
  % \sext{8} is a no-op - WTF is this doing here??
  151&\token{shlo\_l\_imm\_64}&1&$\reg'_A = \sext{8}{(\reg_B \cdot 2^{\immed_X \bmod 64}) \bmod 2^{64}}$\\ \mrule
  152&\token{shlo\_r\_imm\_64}&1&$\reg'_A = \sext{8}{\floor{\reg_B \div 2^{\immed_X \bmod 64}}}$\\ \mrule
  153&\token{shar\_r\_imm\_64}&1&$\reg'_A = \unsigned{\floor{\signed{\reg_B} \div 2^{\immed_X \bmod 64}}}$\\ \mrule
  154&\token{neg\_add\_imm\_64}&1&$\reg'_A = (\immed_X + 2^{64} - \reg_B) \bmod 2^{64}$\\ \mrule
  155&\token{shlo\_l\_imm\_alt\_64}&1&$\reg'_A = (\immed_X \cdot 2^{\reg_B \bmod 64}) \bmod 2^{64}$\\ \mrule
  156&\token{shlo\_r\_imm\_alt\_64}&1&$\reg'_A = \floor{\immed_X \div 2^{\reg_B \bmod 64}}$\\ \mrule
  157&\token{shar\_r\_imm\_alt\_64}&1&$\reg'_A = \unsigned{\floor{\signed{\immed_X} \div 2^{\reg_B \bmod 64}}}$\\ \mrule
  158&\token{rot\_r\_64\_imm}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_A)\sub{i} = \bitsfunc{8}(\reg_B)_{(i + \immed_X) \bmod 64}$\\ \mrule
  159&\token{rot\_r\_64\_imm\_alt}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_A)\sub{i} = \bitsfunc{8}(\immed_X)_{(i + \reg_B) \bmod 64}$\\ \mrule
  160&\token{rot\_r\_32\_imm}&1&$\reg'_A = \sext{4}{x} \ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)\sub{i} = \bitsfunc{4}(\reg_B)_{(i + \immed_X) \bmod 32}$\\ \mrule
  161&\token{rot\_r\_32\_imm\_alt}&1&$\reg'_A = \sext{4}{x} \ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)\sub{i} = \bitsfunc{4}(\immed_X)_{(i + \reg_B) \bmod 32}$\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Two Registers \& One Offset}
\begin{equation}
  \begin{aligned}
    \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
    \reg_B &\equiv \reg_{r_B} \,,\quad
    \reg'_B \equiv \reg'_{r_B} \\
    \using l_X &= \min(4, \max(0, \ell - 1)) \,,\quad&
    \immed_X &\equiv \imath + \signfunc{l_X}(\decode[l_X]{\instructions\subrange{\imath+2}{l_X}})
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  170&\token{branch\_eq}&1&$\token{branch}(\immed_X, \reg_A = \reg_B)$\\ \mrule
  171&\token{branch\_ne}&1&$\token{branch}(\immed_X, \reg_A \ne \reg_B)$\\ \mrule
  172&\token{branch\_lt\_u}&1&$\token{branch}(\immed_X, \reg_A < \reg_B)$\\ \mrule
  173&\token{branch\_lt\_s}&1&$\token{branch}(\immed_X, \signed{\reg_A} < \signed{\reg_B})$\\ \mrule
  174&\token{branch\_ge\_u}&1&$\token{branch}(\immed_X, \reg_A \ge \reg_B)$\\ \mrule
  175&\token{branch\_ge\_s}&1&$\token{branch}(\immed_X, \signed{\reg_A} \ge \signed{\reg_B})$\\
\bottomrule
\end{longtable}

\subsubsection{Instruction with Arguments of Two Registers and Two Immediates}

\begin{equation}
  \begin{aligned}
    \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
    \reg_A &\equiv \reg_{r_A} \,,\quad
    \reg'_A \equiv \reg'_{r_A} \\
    \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
    \reg_B &\equiv \reg_{r_B} \,,\quad
    \reg'_B \equiv \reg'_{r_B} \\
    \using l_X &= \min(4, \instructions_{\imath+2} \bmod 8) \,,\quad&
    \immed_X &= \sext{l_X}{\decode[l_X]{\instructions\subrange{\imath+3}{l_X}}} \\
    \using l_Y &= \min(4, \max(0, \ell - l_X - 2)) \,,\quad&
    \immed_Y &= \sext{l_Y}{\decode[l_Y]{\instructions\subrange{\imath+3+l_X}{l_Y}}}
  \end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}{p{8mm} p{25mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  180&\token{load\_imm\_jump\_ind}&1&$
    \token{djump}((\reg_B + \immed_Y) \bmod 2^{32}) \ ,\qquad
    \reg_A' = \immed_X
  $\\
  \bottomrule
\end{longtable}

\subsubsection{Instructions with Arguments of Three Registers}
\begin{equation}
\begin{aligned}
  \using r_A &= \min(12, (\instructions_{\imath+1}) \bmod 16) \,,\quad&
  \reg_A &\equiv \reg_{r_A} \,,\quad
  \reg'_A \equiv \reg'_{r_A} \\
  \using r_B &= \min(12, \ffrac{\instructions_{\imath+1}}{16}) \,,\quad&
  \reg_B &\equiv \reg_{r_B} \,,\quad
  \reg'_B \equiv \reg'_{r_B} \\
  \using r_D &= \min(12, \instructions_{\imath+2}) \,,\quad&
  \reg_D &\equiv \reg_{r_D} \,,\quad
  \reg'_D \equiv \reg'_{r_D} \\
\end{aligned}
\end{equation}

\renewcommand*{\mrule}{\cmidrule(lr){1-4}}
\begin{longtable}[t]{p{8mm} p{20mm} p{5mm} p{100mm}}
  \toprule
  \thead{$\instructions_\imath$} & \thead{\textbf{Name}} & \thead{$\gascost$} & \thead{\textbf{Mutations}} \\
  \midrule
  \endhead
  190&\token{add\_32}&1&$\reg'_D = \sext{4}{(\reg_A + \reg_B) \bmod 2^{32}}$\\ \mrule
  191&\token{sub\_32}&1&$\reg'_D = \sext{4}{(\reg_A + 2^{32} - (\reg_B \bmod 2^{32})) \bmod 2^{32}}$\\ \mrule
  192&\token{mul\_32}&1&$\reg'_D = \sext{4}{(\reg_A \cdot \reg_B) \bmod 2^{32}}$\\ \mrule
  193&\token{div\_u\_32}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when \reg_B \bmod 2^{32} = 0\\
    \sext{4}{\floor{(\reg_A \bmod 2^{32}) \div (\reg_B \bmod 2^{32})}} &\otherwise
  \end{cases}$\\ \mrule
  194&\token{div\_s\_32}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when b = 0\\
    \unsigned{a} &\when a = -2^{31} \wedge b = -1\\
    \unsigned{\rtz(a \div b)} &\otherwise \\[2pt]
    \multicolumn{2}{l}{\quad \where a = \signedn{4}{\reg_A \bmod 2^{32}}\,,\ b = \signedn{4}{\reg_B \bmod 2^{32}}}\\
  \end{cases}$\\ \mrule
  195&\token{rem\_u\_32}&1&$\reg'_D = \begin{cases}
    \sext{4}{\reg_A \bmod 2^{32}} &\when \reg_B \bmod 2^{32} = 0\\
    \sext{4}{(\reg_A \bmod 2^{32}) \bmod (\reg_B \bmod 2^{32})} &\otherwise
  \end{cases}$\\ \mrule
  196&\token{rem\_s\_32}&1&$\reg'_D = \begin{cases}
    0 &\when a = -2^{31} \wedge b = -1 \\
    \unsigned{\smod(a, b)} &\otherwise \\[2pt]
    \multicolumn{2}{l}{\quad \where a = \signedn{4}{\reg_A \bmod 2^{32}}\,,\ b = \signedn{4}{\reg_B \bmod 2^{32}}}\\
  \end{cases}$\\ \mrule
  197&\token{shlo\_l\_32}&1&$\reg'_D = \sext{4}{(\reg_A \cdot 2^{\reg_B \bmod 32}) \bmod 2^{32}}$\\ \mrule
  198&\token{shlo\_r\_32}&1&$\reg'_D = \sext{4}{\floor{(\reg_A \bmod 2^{32}) \div 2^{\reg_B \bmod 32}}}$\\ \mrule
  199&\token{shar\_r\_32}&1&$\reg'_D = \unsigned{\floor{\signedn{4}{\reg_A \bmod 2^{32}} \div 2^{\reg_B \bmod 32}}}$\\ \mrule

  200&\token{add\_64}&1&$\reg'_D = (\reg_A + \reg_B) \bmod 2^{64}$\\ \mrule
  201&\token{sub\_64}&1&$\reg'_D = (\reg_A + 2^{64} - \reg_B) \bmod 2^{64}$\\ \mrule
  202&\token{mul\_64}&1&$\reg'_D = (\reg_A \cdot \reg_B) \bmod 2^{64}$\\ \mrule
  203&\token{div\_u\_64}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when \reg_B = 0\\
    \floor{\reg_A \div \reg_B} &\otherwise
  \end{cases}$\\ \mrule
  204&\token{div\_s\_64}&1&$\reg'_D = \begin{cases}
    2^{64} - 1 &\when \reg_B = 0\\
    \reg_A &\when \signed{\reg_A} = -2^{63} \wedge \signed{\reg_B} = -1\\
    \unsigned{\rtz(\signed{\reg_A} \div \signed{\reg_B})} &\otherwise
  \end{cases}$\\ \mrule
  205&\token{rem\_u\_64}&1&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    \reg_A \bmod \reg_B &\otherwise
  \end{cases}$\\ \mrule
  206&\token{rem\_s\_64}&1&$\reg'_D = \begin{cases}
    0 &\when \signed{\reg_A} = -2^{63} \wedge \signed{\reg_B} = -1\\
    \unsigned{\smod(\signed{\reg_A}, \signed{\reg_B})} &\otherwise
  \end{cases}$\\ \mrule
  207&\token{shlo\_l\_64}&1&$\reg'_D = (\reg_A \cdot 2^{\reg_B \bmod 64}) \bmod 2^{64}$\\ \mrule
  208&\token{shlo\_r\_64}&1&$\reg'_D = \floor{\reg_A \div 2^{\reg_B \bmod 64}}$\\ \mrule
  209&\token{shar\_r\_64}&1&$\reg'_D = \unsigned{\floor{\signed{\reg_A} \div 2^{\reg_B \bmod 64}}}$\\ \mrule

  210&\token{and}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \wedge \bits{\reg_B}\sub{i}$\\ \mrule
  211&\token{xor}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \oplus \bits{\reg_B}\sub{i}$\\ \mrule
  212&\token{or}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \vee \bits{\reg_B}\sub{i}$\\ \mrule
  213&\token{mul\_upper\_s\_s}&1&$\reg'_D = \unsigned{\floor{(\signed{\reg_A} \cdot \signed{\reg_B}) \div 2^{64}}}$\\ \mrule
  214&\token{mul\_upper\_u\_u}&1&$\reg'_D = \floor{(\reg_A \cdot \reg_B) \div 2^{64}}$\\ \mrule
  215&\token{mul\_upper\_s\_u}&1&$\reg'_D = \unsigned{\floor{(\signed{\reg_A} \cdot \reg_B) \div 2^{64}}}$\\ \mrule
  216&\token{set\_lt\_u}&1&$\reg'_D = \reg_A < \reg_B$\\ \mrule
  217&\token{set\_lt\_s}&1&$\reg'_D = \signed{\reg_A} < \signed{\reg_B}$\\ \mrule
  218&\token{cmov\_iz}&1&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B = 0\\
    \reg_D &\otherwise
  \end{cases}$\\ \mrule
  219&\token{cmov\_nz}&1&$\reg'_D = \begin{cases}
    \reg_A &\when \reg_B \ne 0\\
    \reg_D &\otherwise
  \end{cases}$\\ \mrule
  220&\token{rot\_l\_64}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_D)_{(i + \reg_B) \bmod 64} = \bitsfunc{8}(\reg_A)\sub{i}$\\ \mrule
  221&\token{rot\_l\_32}&1&$\reg'_D = \sext{4}{x}\ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)_{(i + \reg_B) \bmod 32} = \bitsfunc{4}(\reg_A)\sub{i}$\\ \mrule
  222&\token{rot\_r\_64}&1&$\forall i \in \Nmax{64} : \bitsfunc{8}(\reg'_D)\sub{i} = \bitsfunc{8}(\reg_A)_{(i + \reg_B) \bmod 64}$\\ \mrule
  223&\token{rot\_r\_32}&1&$\reg'_D = \sext{4}{x}\ \where x \in \Nbits{32}, \forall i \in \Nmax{32} : \bitsfunc{4}(x)\sub{i} = \bitsfunc{4}(\reg_A)_{(i + \reg_B) \bmod 32}$\\ \mrule
  224&\token{and\_inv}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \wedge \lnot \bits{\reg_B}\sub{i}$\\ \mrule
  225&\token{or\_inv}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \bits{\reg_A}\sub{i} \vee \lnot \bits{\reg_B}\sub{i}$\\ \mrule
  226&\token{xnor}&1&$\forall i \in \Nmax{64} : \bits{\reg'_D}\sub{i} = \lnot ( \bits{\reg_A}\sub{i} \oplus \bits{\reg_B}\sub{i} )$\\ \mrule
  227&\token{max}&1&$\reg'_D = \unsigned{\max \tup{ \signed{\reg_A}, \signed{\reg_B} }}$\\ \mrule
  228&\token{max\_u}&1&$\reg'_D = \max \tup{ \reg_A, \reg_B }$\\ \mrule
  229&\token{min}&1&$\reg'_D = \unsigned{\min \tup{ \signed{\reg_A}, \signed{\reg_B} }}$\\ \mrule
  230&\token{min\_u}&1&$\reg'_D = \min \tup{ \reg_A, \reg_B }$\\
\bottomrule
\end{longtable}

Note that the two signed modulo operations have an idiosyncratic definition, operating as the modulo of the absolute values, but with the sign of the numerator. Formally:
\begin{equation}
  \smod\colon\abracegroup{
    \tuple{\Z, \Z} &\to \Z\\
    \tup{a, b} &\mapsto \begin{cases}
      a &\when b = 0\\
      \text{sgn}(a)(\len{a} \bmod \len{b}) &\otherwise \\
    \end{cases}
  }
\end{equation}

Division operations always round their result towards zero. Formally:
\begin{equation}
  \rtz\colon\abracegroup{
    \Z &\to \Z\\
    x &\mapsto \begin{cases}
      \ceil{x} &\when x < 0\\
      \floor{x} &\otherwise \\
    \end{cases}
  }
\end{equation}

\subsection{Host Call Definition}

An extended version of the \textsc{pvm} invocation which is able to progress an inner \emph{host-call} state-machine in the case of a host-call halt condition is defined as $\Psi_H$:
\begin{align}
  &\Psi_H\colon \abracegroup{
    \tuple{\begin{aligned}
      &\blob, \pvmreg, \gas, \regs,\\&\ram, \contextmutator{X}, X
    \end{aligned}
    }
    &\to
    \tuple{\set{\panic, \oog, \halt} \cup \set{\fault} \times \pvmreg, \pvmreg, \signedgas, \regs, \ram, X}\\
    \tup{\mathbf{c}, \imath, \gascounter, \registers, \mem, f, \mathbf{x}} &\mapsto \begin{cases}
      \multicolumn{2}{l}{\text{let }(\varepsilon', \imath', \gascounter', \registers', \mem') = \Psi(\mathbf{c}, \imath, \gascounter, \registers, \mem):} \\[8pt]
      \tup{\varepsilon', \imath', \gascounter', \registers', \mem', \mathbf{x}} &\when \varepsilon' \in \set{ \halt, \panic, \oog } \cup \set{\fault} \times \pvmreg \\[4pt]
      \tup{\fault \times a, \imath', \gascounter', \registers', \mem', \mathbf{x}} &\when \bigwedge\abracegroup[\;]{
        &\varepsilon' = \host \times h\\[2pt]
        &\fault \times a = f(h, \gascounter', \registers', \mem', \mathbf{x})\\[2pt]
      }\\[10 pt]
      \Psi_H(\mathbf{c}, \imath', \gascounter'', \registers'', \mem'', f, \mathbf{x}'')
       &\when \bigwedge\abracegroup[\;]{
        &\varepsilon' = \host \times h\\[2pt]
        &\tup{\continue, \gascounter'', \registers'', \mem'', \mathbf{x}''} = f(h, \gascounter', \registers', \mem', \mathbf{x})
      }\\[8pt]
      \tup{\varepsilon'', \imath', \gascounter'', \registers'', \mem'', \mathbf{x}''} &\when  \bigwedge\abracegroup[\;]{
        &\varepsilon' = \host \times h\\[2pt]
        &\tup{\varepsilon'', \gascounter'', \registers'', \mem'', \mathbf{x}''} = f(h, \gascounter', \registers', \mem', \mathbf{x})\\[2pt]
        &\varepsilon'' \in \set{\panic, \halt, \oog}
      }\\[8pt]
    \end{cases} \\
    }\!\!\!\!\!\!\!\!\\
    &\contextmutator{X} \equiv \tuple{\N, \gas, \regs, \ram, X} \to \tuple{\set{\continue, \halt, \panic, \oog}, \gas, \regs, \ram, X} \cup \set{\fault} \times \pvmreg
\end{align}

On exit, the instruction counter $\imath'$ references the instruction \emph{which caused the exit}. Should the machine be invoked again using this instruction counter and code, then the same instruction which caused the exit would be executed. This is sensible when the instruction is one which necessarily needs re-executing such as in the case of an out-of-gas or page fault reason.

However, when the exit reason to $\Psi$ is a host-call $\host$, then the resultant instruction-counter has a value of the host-call instruction and resuming with this state would immediately exit with the same result. Re-invoking would therefore require both the post-host-call machine state \emph{and} the instruction counter value for the instruction following the one which resulted in the host-call exit reason. This is always one greater plus the relevant argument skip distance. Resuming the machine with this instruction counter will continue beyond the host-call instruction.

We use both values of instruction-counter for the definition of $\Psi_H$ since if the host-call results in a page fault we need to allow the outer environment to resolve the fault and re-try the host-call. Conversely, if we successfully transition state according to the host-call, then on resumption we wish to begin with the instruction directly following the host-call.

\subsection{Standard Program Initialization}\label{sec:standardprograminit}
The software programs which will run in each of the four instances where the \textsc{pvm} is utilized in the main document have a very typical setup pattern characteristic of an output of a compiler and linker. This means that \textsc{ram} has sections for program-specific read-only data, read-write (heap) data and the stack. An adjunct to this, very typical of our usage patterns is an extra read-only section via which invocation-specific data may be passed (\ie arguments). It thus makes sense to define this properly in a single initializer function. These sections are quantized into \emph{major zones}, and one major zone is always left unallocated between sections in order to reduce accidental overrun. Sections are padded with zeroes to the nearest \textsc{pvm} memory page boundary.

We thus define the standard program code format $\mathbf{p}$, which includes not only the instructions and jump table (previously represented by the term $\mathbf{c}$), but also information on the state of the \textsc{ram} at program start. Given program blob $\mathbf{p}$ and argument data $\mathbf{a}$, we can decode the program code $\mathbf{c}$, registers $\registers$, and \textsc{ram} $\mem$ by invoking the standard initialization function $Y(\mathbf{p}, \mathbf{a})$:
\begin{equation}
Y\colon\abracegroup{
  \tuple{\blob, \blob[:\Cpvminitinputsize]} &\to \tuple{\blob, \regs, \ram}? \\
  \tup{\mathbf{p}, \mathbf{a}} &\mapsto \begin{cases}
    \tup{\mathbf{c}, \registers, \mem} &\when \exists! \tup{\mathbf{c}, \mathbf{o}, \mathbf{w}, z, s} \text{ which satisfy equation \ref{eq:conditions}}\\
    \none &\otherwise
  \end{cases}
}
\end{equation}
With conditions:
\begin{align}\label{eq:conditions}
  &\using \mathcal{E}_3(\len{\mathbf{o}}) \concat \mathcal{E}_3(\len{\mathbf{w}}) \concat \mathcal{E}_2(z) \concat \mathcal{E}_3(s) \concat \mathbf{o} \concat \mathbf{w} \concat \mathcal{E}_4(\len{\mathbf{c}}) \concat \mathbf{c} = \mathbf{p}\\
  &\Cpvminitzonesize = 2^{16}\ ,\quad\Cpvminitinputsize = 2^{24}\\
  &\using \rnp{x \in \N} \equiv \Cpvmpagesize\ceil{ \frac{x}{\Cpvmpagesize} }\quad,\qquad\rnq{x \in \N} \equiv \Cpvminitzonesize\ceil{ \frac{x}{\Cpvminitzonesize} }\\
  &5\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \rnq{\len{\mathbf{w}} + z\Cpvmpagesize} + \rnq{s} + \Cpvminitinputsize \leq 2^{32}
\end{align}
Thus, if the above conditions cannot be satisfied with unique values, then the result is $\none$, otherwise it is a tuple of $\mathbf{c}$ as above and $\mem$, $\registers$ such that:
\begin{equation}\label{eq:memlayout}
  \forall i \in \Nbits{32} : ((\mem_\ram¬value)\sub{i}, (\mem_\ram¬access)_{\floor{\nicefrac{i}{\Cpvmpagesize}}}) = \bracegroup{\begin{alignedat}{5}
    &\tup{\is{\ram¬value}{\mathbf{o}_{i - \Cpvminitzonesize}},\,\is{\ram¬access}{R}} &&\ \when
        \Cpvminitzonesize
            &\ \leq i < \ &&
                \Cpvminitzonesize + \len{\mathbf{o}}\\
    &\tup{0, R} &&\ \when
        \Cpvminitzonesize + \len{\mathbf{o}}
            &\ \leq i < \ &&
                \Cpvminitzonesize + \rnp{\len{\mathbf{o}}} \\
    &(\mathbf{w}_{i - (2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}})}, W) &&\ \when
        2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}}
            &\ \leq i < \ &&
                2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \len{\mathbf{w}}\\
    &\tup{0, W} &&\ \when
        2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \len{\mathbf{w}}
            &\ \leq i < \ &&
                2\Cpvminitzonesize + \rnq{\len{\mathbf{o}}} + \rnp{\len{\mathbf{w}}} + z\Cpvmpagesize\\
    &\tup{0, W} &&\ \when
        2^{32} - 2\Cpvminitzonesize - \Cpvminitinputsize - \rnp{s}
            &\ \leq i < \ &&
                2^{32} - 2\Cpvminitzonesize - \Cpvminitinputsize\\
    &(\mathbf{a}_{i - (2^{32} - \Cpvminitzonesize - \Cpvminitinputsize)}, R) &&\ \when
        2^{32} - \Cpvminitzonesize - \Cpvminitinputsize
            &\ \leq i < \ &&
                2^{32} - \Cpvminitzonesize - \Cpvminitinputsize + \len{\mathbf{a}}\\
    &\tup{0, R} &&\ \when
        2^{32} - \Cpvminitzonesize - \Cpvminitinputsize + \len{\mathbf{a}}
            &\ \leq i < \ &&
                2^{32} - \Cpvminitzonesize - \Cpvminitinputsize + \rnp{\len{\mathbf{a}}}\\
    &\tup{0, \none} &&\otherwise&&&
  \end{alignedat}}\\
\end{equation}
\begin{equation}\label{eq:registers}
  \forall i \in \Nmax{13} : \registers\sub{i} = \begin{cases}
      2^{32} - 2^{16} &\when i = 0\\
      2^{32} - 2\Cpvminitzonesize - \Cpvminitinputsize &\when i = 1\\
      2^{32} - \Cpvminitzonesize - \Cpvminitinputsize &\when i = 7\\
      \len{\mathbf{a}}&\when i = 8\\
      0 &\otherwise
    \end{cases}
\end{equation}

\subsection{Argument Invocation Definition}

The four instances where the \textsc{pvm} is utilized each expect to be able to pass argument data in and receive some return data back. We thus define the common \textsc{pvm} program-argument invocation function $\Psi_M$:
\begin{equation}
  \Psi_M\colon \abracegroup{
    \tuple{
      \blob, \pvmreg, \gas, \blob[:\Cpvminitinputsize], \contextmutator{X}, X
    } &\to \tuple{\gas, \blob \cup \set{\panic, \oog}, X}\\
    \tup{\mathbf{p}, \imath, \gascounter, \mathbf{a}, f, \mathbf{x}} &\mapsto \begin{cases}
      \tup{0, \panic, \mathbf{x}} &\when Y(\mathbf{p}, \mathbf{a}) = \none\\
      R(\gascounter, \Psi_H(\mathbf{c}, \imath, \gascounter, \registers, \mem, f, \mathbf{x})) &\when Y(\mathbf{p}, \mathbf{a}) = \tup{\mathbf{c}, \registers, \mem}\\
      \multicolumn{2}{l}{
        \quad \where R \colon \tup{\gascounter, \tup{\begin{alignedat}{5}
          &\varepsilon,\, &&\imath',\, &&\gascounter',\\
          &\registers',\, &&\mem',\, &&\mathbf{x}'
        \end{alignedat}
        }} \mapsto \begin{cases}
          \tup{u, \oog, \mathbf{x}'} &\when \varepsilon = \oog \\
          \tup{u, \memory'_{\registers'_{7}\dots+\registers'_{8}}, \mathbf{x}'} &\when \varepsilon = \halt \wedge \Nrange{\registers'_{7}}{\registers'_{8}} \subseteq \readable{\mem'} \\
          \tup{u, \sq{}, \mathbf{x}'} &\when \varepsilon = \halt \wedge \Nrange{\registers'_{7}}{\registers'_{8}} \not\subseteq \readable{\mem'} \\
          \tup{u, \panic, \mathbf{x}'} &\otherwise \\
          \multicolumn{2}{l}{\quad \where u = \gascounter - \max(\gascounter', 0)}
        \end{cases}
      }\!\!\!\!\!\!\!\!
    \end{cases}
  }
\end{equation}

Note that the first tuple item is the amount of gas consumed by the operation, but never greater than the amount of gas provided for the operation.
