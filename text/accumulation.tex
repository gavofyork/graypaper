\newcommand*{\srmap}{P}
\newcommand*{\opers}{O}
\newcommand*{\servouts}{B}
\newcommand*{\accumulatedcup}{\overbrace{\accumulated}}

\section{Accumulation}\label{sec:accumulation}

Accumulation may be defined as some function whose arguments are $\mathbf{W}$ and $\delta$ together with selected portions of (at times partially transitioned) state and which yields the posterior service state $\delta'$ together with additional state elements $\iota'$, $\varphi'$ and $\chi'$.

The proposition of accumulation is in fact quite simple: we merely wish to execute the \emph{Accumulate} logic of the service code of each of the services which has at least one work output, passing to it the work outputs and useful contextual information. However, there are three main complications. Firstly, we must define the execution environment of this logic and in particular the host functions available to it. Secondly, we must define the amount of gas to be allowed for each service's execution. Finally, we must determine the nature of transfers within Accumulate which, as we will see, leads to the need for a second entry-point, \emph{on-transfer}.



\subsection{Preimage Integration}

Prior to accumulation, we must first integrate all preimages provided in the lookup extrinsic. The lookup extrinsic is a sequence of pairs of service indices and data. These pairs must be ordered and without duplicates (equation \ref{eq:preimagesareordered} requires this). The data must have been solicited by a service but not yet be provided. Formally:
\begin{align}
  \xtpreimages &\in \lseq \ltuple\N_S\ts\Y\rtuple \rseq \\
  \label{eq:preimagesareordered}\xtpreimages &= \orderuniqby{i}{i \in \xtpreimages} \\
  \forall \tup{s\ts\mathbf{p}} \in \xtpreimages &: \left\{\ 
    \begin{aligned}
      &\keys{\delta[s]_\mathbf{p}}\ \not\ni\ \mathcal{H}(\mathbf{p})\ ,\\
      &\delta[s]_\mathbf{l}[\tup{\mathcal{H}(\mathbf{p}), |\mathbf{p}|}]\ =\ []
    \end{aligned}
  \right.
\end{align}

We define $\delta^\dagger$ as the state after the integration of the preimages:
\begin{align}
    \delta^\dagger = \delta \text{ ex. } \forall \tup{s\ts\mathbf{p}} \in \xtpreimages : \left\{\,\begin{aligned}
      \quad\delta^\dagger[s]_\mathbf{p}[\mathcal{H}(\mathbf{p})] &= \mathbf{p} \\
      \delta^\dagger[s]_\mathbf{l}[\mathcal{H}(\mathbf{p}), |\mathbf{p}|] &= [\tau']
    \end{aligned}\right.\!\!
\end{align}





\subsection{History and Queuing}

Accumulation of a work-package/work-report is deferred in the case that it has a not-yet-fulfilled dependency and is cancelled entirely in the case of an invalid dependency. Dependencies are specified as work-package hashes and in order to know which work-packages have been accumulated already, we maintain a history of what has been accumulated. This history, $\accumulated$, is sufficiently large for an epoch worth of work-reports. Formally:
\begin{align}
  \accumulated &\in \seq{\{\H\}}_\mathsf{E} \\
  \accumulatedcup &\equiv \bigcup_{x \in \accumulated}(x)
\end{align}

We also maintain knowledge of ready (\ie available and/or audited) but not-yet-accumulated work-reports in the state item $\ready$. Each of these were made available at most one epoch ago but have or had unfulfilled dependencies. Alongside the work-report itself, we retain its unaccumulated dependencies, a set of work-package hashes. Formally:
\begin{align}
  \ready &\in \seq{\seq{(\mathbb{W}, \{\H\})}}_\mathsf{E}
\end{align}

The newly available work-reports, $\mathbf{W}$, are partitioned into two sequences based on the condition of having zero prerequisite work-reports. Those meeting the condition, $\mathbf{W}^!$, are accumulated immediately. Those not, $\mathbf{W}^Q$, are for queued execution. Formally:
\begin{align}
  \mathbf{W}^! &\equiv [ w \mid w \orderedin \mathbf{W}, |(w_x)_\mathbf{p}| = 0 \wedge w_\wr¬srlookup = \{\} ] \\
  \mathbf{W}^Q &\equiv E(\sq{
    D(w) \mid
    w \orderedin \mathbf{W},
    |(w_x)_\mathbf{p}| > 0 \vee w_\wr¬srlookup \ne \{\}
  }, \accumulatedcup)\!\!\!\!\\
  D(w) &\equiv (w, \{(w_x)_\mathbf{p}\} \cup \keys{w_\wr¬srlookup})
\end{align}

We define the queue-editing function $E$, which is essentially a mutator function for items such as those of $\ready$, parameterized by sets of now-accumulated work-package hashes (those in $\accumulated$). It is used to update queues of work-reports when some of them are accumulated. Functionally, it removes all entries whose work-report's hash is in the parameter's keys, removes any dependencies which appear in said set and, crucially, removes any entries whose segment-root correspondences diverge from those in the dictionary. Formally:
\begin{equation}
  E\colon\left\{\begin{aligned}
      &(\seq{(\mathbb{W}, \{\H\})}, \{\H\}) \to \seq{(\mathbb{W}, \{\H\})} \\
    &(\mathbf{r}, \mathbf{x}) \mapsto \left[
      (w, \mathbf{d} \setminus \mathbf{x})
      \,\middle\vert\,
      \left\{\,\begin{aligned}
        &(w, \mathbf{d}) \orderedin \mathbf{r} ,\\
        &(w_s)_h \not\in \mathbf{x}
      \end{aligned}\right.
      \right]
  \end{aligned}\right.
\end{equation}

We further define the accumulation priority queue function $Q$, which provides the sequence of work-reports which are accumulatable given a set of not-yet-accumulated work-reports and their dependencies.
\begin{equation}
  Q\colon\left\{\begin{aligned}
    &\seq{(\mathbb{W}, \{\H\})} \to \seq{\mathbb{W}} \\
    &\mathbf{r} \mapsto \begin{cases}
      [] &\when \mathbf{g} = [] \\
      \mathbf{g} \frown Q(E(\mathbf{r}, \srmap(\mathbf{g})))\!\!\!\! &\otherwise \\
      \multicolumn{2}{l}{\,\where \mathbf{g} = [w \mid (w, \{\}) \orderedin \mathbf{r}]}
    \end{cases}
  \end{aligned}\right.
\end{equation}

Finally, we define the mapping function $\srmap$ which extracts the corresponding work-package hashes from a set of work-reports:
\begin{equation}
  \srmap\colon\left\{\begin{aligned}
    \{\mathbb{W}\} &\to \{\H\}\\
    \mathbf{w} &\mapsto \{ (w_s)_h \mid w \in \mathbf{w} \}
  \end{aligned}\right.
\end{equation}

We may now define the sequence of accumulatable work-reports in this block as $\mathbf{W}^*$:
\begin{align}
  \using m &= \mathbf{H}_t \bmod \mathsf{E}\\
  \mathbf{W}^* &\equiv \mathbf{W}^! \frown Q(\mathbf{q}) \\
  \quad\where \mathbf{q} &= E(\wideparen{\ready_{m\dots}} \concat \wideparen{\ready_{\dots m}} \concat \mathbf{W}^Q, \srmap(\mathbf{W}^!))
\end{align}

\subsection{Execution}

We work with a limited amount of gas per block and therefore may not be able to process all items in $\mathbf{W}^*$ in a single block. There are two slightly antagonistic factors allowing us to optimize the amount of work-items, and thus work-reports, accumulated in a single block:

Firstly, while we have a well-known gas-limit for each work-item to be accumulated, accumulation may still result in a lower amount of gas used. Only after a work-item is accumulated can it be known if it uses less gas than the advertised limit. This implies a sequential execution pattern.

Secondly, since \textsc{pvm} setup cannot be expected to be zero-cost, we wish to amortize this cost over as many work-items as possible. This can be done by aggregating work-items associated with the same service into the same \textsc{pvm} invocation. This implies a non-sequential execution pattern.

We resolve this by defining a function $\Delta_+$ which accumulates work-reports sequentially, and which itself utilizes a function $\Delta_*$ which accumulates work-reports in a non-sequential, service-aggregated manner.

Only once all such accumulation is executed do we integrate the results and thus define the relevant posterior state items. In doing so we also integrate the consequences of any \emph{deferred-transfers} implied by accumulation.

Our formalisms begin by defining $\partialstate$ as a characterization (\ie values capable of representing) of state components which are both needed and mutable by the accumulation process. This comprises the service accounts state (as in $\delta$), the upcoming validator keys $\iota$, the queue of work-reports $\varphi$ and the privileges state $\chi$. Formally:
\begin{equation}
  \label{eq:partialstate}
  \partialstate \equiv \left(\begin{aligned}
    &\isa{\mathbf{d}}{\dict{\N_S}{\mathbb{A}}} \,,\;
    \isa{\mathbf{i}}{\seq{\mathbb{K}}_\mathsf{V}} \,,\;
    \isa{\mathbf{q}}{\seq{\seq{\H}_\mathsf{Q}}_\mathsf{C}} \,,\\
    &\isa{\mathbf{x}}{(\N_S,\N_S,\N_S,\dict{\N_S}{\N_G})}
  \end{aligned}\right)
\end{equation}

We denote the set characterizing a \emph{deferred transfer} as $\defxfer$, noting that a transfer includes a memo component $m$ of $\mathsf{W}_T = 128$ octets, together with the service index of the sender $s$, the service index of the receiver $d$, the balance to be transferred $a$ and the gas limit $g$ for the transfer. Formally:
\begin{align}
  \defxfer \equiv \ltuple\isa{s}{\N_S}\ts\isa{d}{\N_S}\ts\isa{a}{\N_B}\ts\isa{m}{\Y_{\mathsf{W}_T}}\ts\isa{g}{\N_G}\rtuple
\end{align}

Finally, we denote the set of service/hash pairs, utilized as a service-indexed commitment to the accumulation output, as $\servouts$:
\begin{equation}
  \servouts \equiv \{(\N_S, \H)\}
\end{equation}

We define the outer accumulation function $\Delta_+$ which transforms a gas-limit, a sequence of work-reports, an initial partial-state and a dictionary of services enjoying free accumulation, into a tuple of the number of work-results accumulated, a posterior state-context, the resultant deferred-transfers and accumulation-output pairings:
\begin{equation}
  \Delta_+\colon\left\{\begin{aligned}
    &(\N_G, \seq{\mathbb{W}}, \partialstate, \dict{\N_S}{\N_G}) \to (\N, \partialstate, \defxfers, \servouts) \\
    &(g, \mathbf{w}, \mathbf{o}, \mathbf{f}) \!\mapsto\! \begin{cases}
      (0, \mathbf{o}, [], \{\}) &
        \when i = 0 \\
      (i + j, \mathbf{o}', \mathbf{t}^* \!\!\concat \mathbf{t}, \mathbf{b}^* \!\cup \mathbf{b})\!\!\!\! &
        \otherwise\!\!\!\!\!\!\!\! \\
    \end{cases} \\
    &\quad\where i = \max(\N_{|\mathbf{w}| + 1}): \sum_{w \in \mathbf{w}_{\dots i}}\sum_{r \in w_\mathbf{r}}(r_g) \le g \\
    &\quad\also (g^*, \mathbf{o}^*, \mathbf{t}^*, \mathbf{b}^*) = \Delta_*(\mathbf{o}, \mathbf{w}_{\dots i}, \mathbf{f}) \\
    &\quad\also (j, \mathbf{o}', \mathbf{t}, \mathbf{b}) = \Delta_+(g - g^*, \mathbf{w}_{i\dots}, \mathbf{o}^*, \{\})
  \end{aligned}\right.
\end{equation}

We come to define the parallelized accumulation function $\Delta_*$ which, with the help of the single-service accumulation function $\Delta_1$, transforms an initial state-context, together with a sequence of work-reports and a dictionary of privileged always-accumulate services, into a tuple of the total gas utilized in \textsc{pvm} execution $u$, a posterior state-context $(\mathbf{x}', \mathbf{d}', \mathbf{i}', \mathbf{q}')$ and the resultant accumulation-output pairings $\mathbf{b}$ and deferred-transfers $\wideparen{\mathbf{t}}$:
\begin{equation}
  \Delta_*\colon\left\{\;\begin{aligned}
    &(\partialstate, \seq{\mathbb{W}}, \dict{\N_S}{\N_G}) \to (\N_G, \partialstate, \defxfers, \servouts) \\
    &(\mathbf{o}, \mathbf{w}, \mathbf{f}) \mapsto (u, (\mathbf{x}', \mathbf{d}', \mathbf{i}', \mathbf{q}'), \wideparen{\mathbf{t}}, \mathbf{b})\!\!\!\!\!\!\\
    &\text{where:}\\
    &\ \begin{aligned}
      \mathbf{s} &= \{ \mathbf{r}_s \mid w \in \mathbf{w}, \mathbf{r} \in w_\mathbf{r} \} \cup \keys{\mathbf{f}} \\
      u &= \sum_{s \in \mathbf{s}}(\Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, s)_u) \\
      \mathbf{b} &= \{ (s, b) \mid s \in \mathbf{s},\, b = \Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, s)_b,\, b \ne \none \} \\
      \mathbf{t} &= [\Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, s)_\mathbf{t} \mid s \orderedin \mathbf{s}] \\
      &((m, a, v, \mathbf{z}), \mathbf{d}, \mathbf{i}, \mathbf{q}) = \mathbf{o} \\
      \mathbf{x}' &= (\Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, m)_\mathbf{o})_\mathbf{x} \\
      \mathbf{i}' &= (\Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, a)_\mathbf{o})_\mathbf{i} \\
      \mathbf{q}' &= (\Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, v)_\mathbf{o})_\mathbf{q} \\
      \mathbf{d}' &= \{ s \mapsto \mathbf{d}_s \mid s \in \keys{\mathbf{d}} \setminus \mathbf{s} \} \cup \bigcup_{s \in \mathbf{s}}((\Delta_1(\mathbf{o}, \mathbf{w}, \mathbf{f}, s)_\mathbf{o})_\mathbf{d})\!\!\!\!\!\!\!\!
    \end{aligned}
  \end{aligned}\right.
\end{equation}

We note that all newly added service indices, defined in the above context as $\bigcup_{s \in \mathbf{s}}\keys{(\Delta_1(\mathbf{o}, \mathbf{w}, s)_\mathbf{o})_\mathbf{d}} \setminus \mathbf{s}$, must not conflict with the indices of existing services $\keys{\delta}$ or other newly added services. This should never happen, since new indices are explicitly selected to avoid such conflicts, but in the unlikely event it happens, the block must be considered invalid.

The single-service accumulation function, $\Delta_1$, transforms an initial state-context, sequence of work-reports and a service index into an alterations state-context, a sequence of \emph{transfers}, a possible accumulation-output and the actual \textsc{pvm} gas used. This function wrangles the work-items of a particular service from a set of work-reports and invokes \textsc{pvm} execution with said data:
\begin{align}
  &\mathbb{O} \equiv \tuple{\isa{o}{\Y \cup \mathbb{J}}, \isa{l}{\H}, \isa{k}{\H}, \isa{a}{\Y}} \\
  &\Delta_1 \colon \left\{\;\begin{aligned}
    &\begin{aligned}
      (\partialstate, \seq{\mathbb{W}}, \dict{\N_S}{\N_G}, \N_S) &\to \tuple{
        \begin{aligned}
          &\isa{\mathbf{o}}{\partialstate}, \isa{\mathbf{t}}{\defxfers},\\
          &\isa{b}{\H\bm{?}}, \isa{u}{\N_G}
        \end{aligned}
      } \\
      (\mathbf{o}, \mathbf{w}, \mathbf{f}, s) &\mapsto \Psi_A(\mathbf{o}, s, g, \mathbf{p})
    \end{aligned} \\
    &\text{where:} \\
    &\ \begin{aligned}
      g &= \subifnone(\mathbf{f}_s, 0) + \!\!\!\!\sum_{w \in \mathbf{w}, \mathbf{r} \in w_\mathbf{r} , \mathbf{r}_s = s}\!\!\!\!(\mathbf{r}_g) \\
      \mathbf{p} &= \left[ \tup{\begin{alignedat}{3}
        \is{o&}{\mathbf{r}_o}\ts\is{&l&}{\mathbf{r}_l}\ts\\
        \is{a&}{w_o}\ts\is{&k&}{(w_s)_h}
      \end{alignedat}}
      \,\middle\vert\ 
      w \orderedin \mathbf{w}, \mathbf{r} \orderedin w_\mathbf{r}, \mathbf{r}_s = s
    \,\right]
    \end{aligned}
  \end{aligned}\right.\!\!\!\!
\end{align}

This introduces $\mathbb{O}$, the set of wrangled \emph{operand tuples}, used as an operand to the \textsc{pvm} Accumulation function $\Psi_A$. It also draws upon $g$, the gas limit implied by the work-reports and gas-privileges for $s$ and $\mathbf{p}$, a rephrasing of the work-items for $s$ within $\mathbf{w}$ into a sequence of operand tuples $\mathbb{O}$.

\subsection{Deferred Transfers and State Integration}

Given the result of the top-level $\Delta_+$, we may define the posterior state $\chi'$, $\varphi'$ and $\iota'$ as well as the second intermediate state of the service-accounts $\delta^\ddagger$ and the \textsc{Beefy} commitment map $\beefycommitmap$:
\begin{align}
  \using g &= \max\left(\mathsf{G}_T, \mathsf{G}_A\cdot \mathsf{C} + \sum_{x \in \mathcal{V}(\chi_\mathbf{g})}(x)\right)\\
  \using (n, \mathbf{o}, \mathbf{t}, \beefycommitmap) &= \Delta_+(g, \mathbf{W}^*, (\chi, \delta^\dagger, \iota, \varphi), \chi_\mathbf{g}) \\
  (\chi', \delta^\ddagger, \iota', \varphi') &\equiv \mathbf{o}
\end{align}

Note that the accumulation commitment map $\beefycommitmap$ is set of pairs of indices of the output-yielding accumulated services to their accumulation result. This is utilized in equation \ref{eq:buildbeefymap}, when determining the accumulation-result tree root for the present block, useful for the \textsc{Beefy} protocol.

We have denoted the sequence of implied transfers as $\mathbf{t}$, ordered internally according to the source service's execution. We define a selection function $R$, which maps a sequence of deferred transfers and a desired destination service index into the sequence of transfers targeting said service, ordered primarily according to the source service index and secondarily their order within $\mathbf{t}$. Formally:
\begin{align}
  R\colon \left\{\;\begin{aligned}
    (\defxfers, \N_S) &\to \defxfers \\
    (\mathbf{t}, d) &\mapsto \left[\,t \mid s \orderedin \N_S,\ t \orderedin \mathbf{t},\ t_s = s,\ t_d = d\,\right]
  \end{aligned}\right.
\end{align}

The posterior state $\delta'$ may then be defined as the second intermediate state with all the deferred effects of the transfers applied:
\begin{equation}
  \delta' = \{ s \mapsto \Psi_T(\delta^\ddagger, s, R(\mathbf{t}, s)) \mid (s \mapsto a) \in \delta^\ddagger \}
\end{equation}

Note that $\Psi_T$ is defined in appendix \ref{sec:ontransferinvocation} such that it results in $\delta^\ddagger[d]$, \ie no difference to the account's intermediate state, if $R(d) = []$, \ie said account received no transfers.

We define the final state of the ready queue and the accumulated map by integrating those work-reports which were accumulated in this block and shifting any from the prior state with the oldest such items being dropped entirely:
\begin{align}
  \accumulated'_{\mathsf{E} - 1} &= \srmap(\mathbf{W}^*_{\dots n}) \\
  \forall i \in \N_\mathsf{E - 1}: \accumulated'_{i} &\equiv \accumulated_{i + 1} \\
  \forall i \in \N_\mathsf{E} : \ready'^\circlearrowleft_{m - i} &\equiv \begin{cases}
    E(\mathbf{W}^Q, \accumulated'_{\mathsf{E} - 1}) &\when i = 0 \\
    [] &\when 1 \le i < \tau' - \tau \\
    E(\ready^\circlearrowleft_{m - i}, \accumulated'_{\mathsf{E} - 1}) &\when i \ge \tau' - \tau
  \end{cases}
\end{align}
